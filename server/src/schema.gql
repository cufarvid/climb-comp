# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCategory {
  avg: CategoryAvgAggregate
  count: CategoryCountAggregate
  max: CategoryMaxAggregate
  min: CategoryMinAggregate
  sum: CategorySumAggregate
}

type AggregateClub {
  avg: ClubAvgAggregate
  count: ClubCountAggregate
  max: ClubMaxAggregate
  min: ClubMinAggregate
  sum: ClubSumAggregate
}

type AggregateComment {
  avg: CommentAvgAggregate
  count: CommentCountAggregate
  max: CommentMaxAggregate
  min: CommentMinAggregate
  sum: CommentSumAggregate
}

type AggregateCompetition {
  avg: CompetitionAvgAggregate
  count: CompetitionCountAggregate
  max: CompetitionMaxAggregate
  min: CompetitionMinAggregate
  sum: CompetitionSumAggregate
}

type AggregateCompetitionType {
  avg: CompetitionTypeAvgAggregate
  count: CompetitionTypeCountAggregate
  max: CompetitionTypeMaxAggregate
  min: CompetitionTypeMinAggregate
  sum: CompetitionTypeSumAggregate
}

type AggregateCompetitor {
  avg: CompetitorAvgAggregate
  count: CompetitorCountAggregate
  max: CompetitorMaxAggregate
  min: CompetitorMinAggregate
  sum: CompetitorSumAggregate
}

type AggregateCountry {
  avg: CountryAvgAggregate
  count: CountryCountAggregate
  max: CountryMaxAggregate
  min: CountryMinAggregate
  sum: CountrySumAggregate
}

type AggregateGrade {
  avg: GradeAvgAggregate
  count: GradeCountAggregate
  max: GradeMaxAggregate
  min: GradeMinAggregate
  sum: GradeSumAggregate
}

type AggregateLocation {
  avg: LocationAvgAggregate
  count: LocationCountAggregate
  max: LocationMaxAggregate
  min: LocationMinAggregate
  sum: LocationSumAggregate
}

type AggregateRegion {
  avg: RegionAvgAggregate
  count: RegionCountAggregate
  max: RegionMaxAggregate
  min: RegionMinAggregate
  sum: RegionSumAggregate
}

type AggregateRegistration {
  avg: RegistrationAvgAggregate
  count: RegistrationCountAggregate
  max: RegistrationMaxAggregate
  min: RegistrationMinAggregate
  sum: RegistrationSumAggregate
}

type AggregateResult {
  avg: ResultAvgAggregate
  count: ResultCountAggregate
  max: ResultMaxAggregate
  min: ResultMinAggregate
  sum: ResultSumAggregate
}

type AggregateRoute {
  avg: RouteAvgAggregate
  count: RouteCountAggregate
  max: RouteMaxAggregate
  min: RouteMinAggregate
  sum: RouteSumAggregate
}

type AggregateScoreBoulder {
  avg: ScoreBoulderAvgAggregate
  count: ScoreBoulderCountAggregate
  max: ScoreBoulderMaxAggregate
  min: ScoreBoulderMinAggregate
  sum: ScoreBoulderSumAggregate
}

type AggregateScoreLead {
  avg: ScoreLeadAvgAggregate
  count: ScoreLeadCountAggregate
  max: ScoreLeadMaxAggregate
  min: ScoreLeadMinAggregate
  sum: ScoreLeadSumAggregate
}

type AggregateScoreSpeed {
  avg: ScoreSpeedAvgAggregate
  count: ScoreSpeedCountAggregate
  max: ScoreSpeedMaxAggregate
  min: ScoreSpeedMinAggregate
  sum: ScoreSpeedSumAggregate
}

type AggregateSeason {
  avg: SeasonAvgAggregate
  count: SeasonCountAggregate
  max: SeasonMaxAggregate
  min: SeasonMinAggregate
  sum: SeasonSumAggregate
}

type AggregateStartList {
  avg: StartListAvgAggregate
  count: StartListCountAggregate
  max: StartListMaxAggregate
  min: StartListMinAggregate
  sum: StartListSumAggregate
}

type AggregateUser {
  avg: UserAvgAggregate
  count: UserCountAggregate
  max: UserMaxAggregate
  min: UserMinAggregate
  sum: UserSumAggregate
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  count: NestedIntFilter
  equals: Boolean
  max: NestedBoolFilter
  min: NestedBoolFilter
  not: NestedBoolWithAggregatesFilter
}

type Category {
  ageFrom: Int!
  ageTo: Int!
  competitors(cursor: CompetitorWhereUniqueInput, distinct: [CompetitorScalarFieldEnum!], orderBy: [CompetitorOrderByInput!], skip: Int, take: Int, where: CompetitorWhereInput): [Competitor!]!
  description: String
  id: Int!
  name: String!
  routes(cursor: RouteWhereUniqueInput, distinct: [RouteScalarFieldEnum!], orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): [Route!]!
}

type CategoryAvgAggregate {
  ageFrom: Float!
  ageTo: Float!
  id: Float!
}

type CategoryCountAggregate {
  _all: Int!
  ageFrom: Int!
  ageTo: Int!
  description: Int
  id: Int!
  name: Int
}

input CategoryCreateInput {
  ageFrom: Int!
  ageTo: Int!
  competitors: CompetitorCreateNestedManyWithoutCategoryInput
  description: String
  name: String!
  routes: RouteCreateNestedManyWithoutCategoryInput
}

input CategoryCreateManyInput {
  ageFrom: Int!
  ageTo: Int!
  description: String
  id: Int
  name: String!
}

input CategoryCreateNestedOneWithoutCompetitorsInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutCompetitorsInput
  create: CategoryCreateWithoutCompetitorsInput
}

input CategoryCreateNestedOneWithoutRoutesInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutRoutesInput
  create: CategoryCreateWithoutRoutesInput
}

input CategoryCreateOrConnectWithoutCompetitorsInput {
  create: CategoryCreateWithoutCompetitorsInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateOrConnectWithoutRoutesInput {
  create: CategoryCreateWithoutRoutesInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutCompetitorsInput {
  ageFrom: Int!
  ageTo: Int!
  description: String
  name: String!
  routes: RouteCreateNestedManyWithoutCategoryInput
}

input CategoryCreateWithoutRoutesInput {
  ageFrom: Int!
  ageTo: Int!
  competitors: CompetitorCreateNestedManyWithoutCategoryInput
  description: String
  name: String!
}

type CategoryGroupBy {
  ageFrom: Int!
  ageTo: Int!
  avg: CategoryAvgAggregate
  count: CategoryCountAggregate
  description: String
  id: Int!
  max: CategoryMaxAggregate
  min: CategoryMinAggregate
  name: String!
  sum: CategorySumAggregate
}

type CategoryMaxAggregate {
  ageFrom: Int!
  ageTo: Int!
  description: String
  id: Int!
  name: String
}

type CategoryMinAggregate {
  ageFrom: Int!
  ageTo: Int!
  description: String
  id: Int!
  name: String
}

input CategoryOrderByInput {
  ageFrom: SortOrder
  ageTo: SortOrder
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input CategoryRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

enum CategoryScalarFieldEnum {
  ageFrom
  ageTo
  description
  id
  name
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  ageFrom: IntWithAggregatesFilter
  ageTo: IntWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CategorySumAggregate {
  ageFrom: Int!
  ageTo: Int!
  id: Int!
}

input CategoryUpdateInput {
  ageFrom: IntFieldUpdateOperationsInput
  ageTo: IntFieldUpdateOperationsInput
  competitors: CompetitorUpdateManyWithoutCategoryInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  routes: RouteUpdateManyWithoutCategoryInput
}

input CategoryUpdateManyMutationInput {
  ageFrom: IntFieldUpdateOperationsInput
  ageTo: IntFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateOneRequiredWithoutCompetitorsInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutCompetitorsInput
  create: CategoryCreateWithoutCompetitorsInput
  update: CategoryUpdateWithoutCompetitorsInput
  upsert: CategoryUpsertWithoutCompetitorsInput
}

input CategoryUpdateOneRequiredWithoutRoutesInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutRoutesInput
  create: CategoryCreateWithoutRoutesInput
  update: CategoryUpdateWithoutRoutesInput
  upsert: CategoryUpsertWithoutRoutesInput
}

input CategoryUpdateWithoutCompetitorsInput {
  ageFrom: IntFieldUpdateOperationsInput
  ageTo: IntFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  routes: RouteUpdateManyWithoutCategoryInput
}

input CategoryUpdateWithoutRoutesInput {
  ageFrom: IntFieldUpdateOperationsInput
  ageTo: IntFieldUpdateOperationsInput
  competitors: CompetitorUpdateManyWithoutCategoryInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpsertWithoutCompetitorsInput {
  create: CategoryCreateWithoutCompetitorsInput!
  update: CategoryUpdateWithoutCompetitorsInput!
}

input CategoryUpsertWithoutRoutesInput {
  create: CategoryCreateWithoutRoutesInput!
  update: CategoryUpdateWithoutRoutesInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  ageFrom: IntFilter
  ageTo: IntFilter
  competitors: CompetitorListRelationFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
  routes: RouteListRelationFilter
}

input CategoryWhereUniqueInput {
  id: Int
}

type Club {
  address: String
  competitions(cursor: CompetitionWhereUniqueInput, distinct: [CompetitionScalarFieldEnum!], orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): [Competition!]!
  competitors(cursor: CompetitorWhereUniqueInput, distinct: [CompetitorScalarFieldEnum!], orderBy: [CompetitorOrderByInput!], skip: Int, take: Int, where: CompetitorWhereInput): [Competitor!]!
  createdAt: DateTime!
  description: String
  id: Int!
  location: Location!
  locationId: Int!
  name: String!
  updatedAt: DateTime!
}

type ClubAvgAggregate {
  id: Float!
  locationId: Float!
}

type ClubCountAggregate {
  _all: Int!
  address: Int
  createdAt: Int
  description: Int
  id: Int!
  locationId: Int!
  name: Int
  updatedAt: Int
}

input ClubCreateInput {
  address: String
  competitions: CompetitionCreateNestedManyWithoutClubInput
  competitors: CompetitorCreateNestedManyWithoutClubInput
  createdAt: DateTime
  description: String
  location: LocationCreateNestedOneWithoutClubsInput!
  name: String!
  updatedAt: DateTime
}

input ClubCreateManyInput {
  address: String
  createdAt: DateTime
  description: String
  id: Int
  locationId: Int!
  name: String!
  updatedAt: DateTime
}

input ClubCreateManyLocationInput {
  address: String
  createdAt: DateTime
  description: String
  id: Int
  name: String!
  updatedAt: DateTime
}

input ClubCreateManyLocationInputEnvelope {
  data: [ClubCreateManyLocationInput!]!
  skipDuplicates: Boolean
}

input ClubCreateNestedManyWithoutLocationInput {
  connect: [ClubWhereUniqueInput!]
  connectOrCreate: [ClubCreateOrConnectWithoutLocationInput!]
  create: [ClubCreateWithoutLocationInput!]
  createMany: ClubCreateManyLocationInputEnvelope
}

input ClubCreateNestedOneWithoutCompetitionsInput {
  connect: ClubWhereUniqueInput
  connectOrCreate: ClubCreateOrConnectWithoutCompetitionsInput
  create: ClubCreateWithoutCompetitionsInput
}

input ClubCreateNestedOneWithoutCompetitorsInput {
  connect: ClubWhereUniqueInput
  connectOrCreate: ClubCreateOrConnectWithoutCompetitorsInput
  create: ClubCreateWithoutCompetitorsInput
}

input ClubCreateOrConnectWithoutCompetitionsInput {
  create: ClubCreateWithoutCompetitionsInput!
  where: ClubWhereUniqueInput!
}

input ClubCreateOrConnectWithoutCompetitorsInput {
  create: ClubCreateWithoutCompetitorsInput!
  where: ClubWhereUniqueInput!
}

input ClubCreateOrConnectWithoutLocationInput {
  create: ClubCreateWithoutLocationInput!
  where: ClubWhereUniqueInput!
}

input ClubCreateWithoutCompetitionsInput {
  address: String
  competitors: CompetitorCreateNestedManyWithoutClubInput
  createdAt: DateTime
  description: String
  location: LocationCreateNestedOneWithoutClubsInput!
  name: String!
  updatedAt: DateTime
}

input ClubCreateWithoutCompetitorsInput {
  address: String
  competitions: CompetitionCreateNestedManyWithoutClubInput
  createdAt: DateTime
  description: String
  location: LocationCreateNestedOneWithoutClubsInput!
  name: String!
  updatedAt: DateTime
}

input ClubCreateWithoutLocationInput {
  address: String
  competitions: CompetitionCreateNestedManyWithoutClubInput
  competitors: CompetitorCreateNestedManyWithoutClubInput
  createdAt: DateTime
  description: String
  name: String!
  updatedAt: DateTime
}

type ClubGroupBy {
  address: String
  avg: ClubAvgAggregate
  count: ClubCountAggregate
  createdAt: DateTime!
  description: String
  id: Int!
  locationId: Int!
  max: ClubMaxAggregate
  min: ClubMinAggregate
  name: String!
  sum: ClubSumAggregate
  updatedAt: DateTime!
}

input ClubListRelationFilter {
  every: ClubWhereInput
  none: ClubWhereInput
  some: ClubWhereInput
}

type ClubMaxAggregate {
  address: String
  createdAt: DateTime
  description: String
  id: Int!
  locationId: Int!
  name: String
  updatedAt: DateTime
}

type ClubMinAggregate {
  address: String
  createdAt: DateTime
  description: String
  id: Int!
  locationId: Int!
  name: String
  updatedAt: DateTime
}

input ClubOrderByInput {
  address: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  locationId: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ClubRelationFilter {
  is: ClubWhereInput
  isNot: ClubWhereInput
}

enum ClubScalarFieldEnum {
  address
  createdAt
  description
  id
  locationId
  name
  updatedAt
}

input ClubScalarWhereInput {
  AND: [ClubScalarWhereInput!]
  NOT: [ClubScalarWhereInput!]
  OR: [ClubScalarWhereInput!]
  address: StringNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  locationId: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input ClubScalarWhereWithAggregatesInput {
  AND: [ClubScalarWhereWithAggregatesInput!]
  NOT: [ClubScalarWhereWithAggregatesInput!]
  OR: [ClubScalarWhereWithAggregatesInput!]
  address: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  locationId: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ClubSumAggregate {
  id: Int!
  locationId: Int!
}

input ClubUpdateInput {
  address: NullableStringFieldUpdateOperationsInput
  competitions: CompetitionUpdateManyWithoutClubInput
  competitors: CompetitorUpdateManyWithoutClubInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutClubsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ClubUpdateManyMutationInput {
  address: NullableStringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ClubUpdateManyWithWhereWithoutLocationInput {
  data: ClubUpdateManyMutationInput!
  where: ClubScalarWhereInput!
}

input ClubUpdateManyWithoutLocationInput {
  connect: [ClubWhereUniqueInput!]
  connectOrCreate: [ClubCreateOrConnectWithoutLocationInput!]
  create: [ClubCreateWithoutLocationInput!]
  createMany: ClubCreateManyLocationInputEnvelope
  delete: [ClubWhereUniqueInput!]
  deleteMany: [ClubScalarWhereInput!]
  disconnect: [ClubWhereUniqueInput!]
  set: [ClubWhereUniqueInput!]
  update: [ClubUpdateWithWhereUniqueWithoutLocationInput!]
  updateMany: [ClubUpdateManyWithWhereWithoutLocationInput!]
  upsert: [ClubUpsertWithWhereUniqueWithoutLocationInput!]
}

input ClubUpdateOneRequiredWithoutCompetitionsInput {
  connect: ClubWhereUniqueInput
  connectOrCreate: ClubCreateOrConnectWithoutCompetitionsInput
  create: ClubCreateWithoutCompetitionsInput
  update: ClubUpdateWithoutCompetitionsInput
  upsert: ClubUpsertWithoutCompetitionsInput
}

input ClubUpdateOneRequiredWithoutCompetitorsInput {
  connect: ClubWhereUniqueInput
  connectOrCreate: ClubCreateOrConnectWithoutCompetitorsInput
  create: ClubCreateWithoutCompetitorsInput
  update: ClubUpdateWithoutCompetitorsInput
  upsert: ClubUpsertWithoutCompetitorsInput
}

input ClubUpdateWithWhereUniqueWithoutLocationInput {
  data: ClubUpdateWithoutLocationInput!
  where: ClubWhereUniqueInput!
}

input ClubUpdateWithoutCompetitionsInput {
  address: NullableStringFieldUpdateOperationsInput
  competitors: CompetitorUpdateManyWithoutClubInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutClubsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ClubUpdateWithoutCompetitorsInput {
  address: NullableStringFieldUpdateOperationsInput
  competitions: CompetitionUpdateManyWithoutClubInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutClubsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ClubUpdateWithoutLocationInput {
  address: NullableStringFieldUpdateOperationsInput
  competitions: CompetitionUpdateManyWithoutClubInput
  competitors: CompetitorUpdateManyWithoutClubInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ClubUpsertWithWhereUniqueWithoutLocationInput {
  create: ClubCreateWithoutLocationInput!
  update: ClubUpdateWithoutLocationInput!
  where: ClubWhereUniqueInput!
}

input ClubUpsertWithoutCompetitionsInput {
  create: ClubCreateWithoutCompetitionsInput!
  update: ClubUpdateWithoutCompetitionsInput!
}

input ClubUpsertWithoutCompetitorsInput {
  create: ClubCreateWithoutCompetitorsInput!
  update: ClubUpdateWithoutCompetitorsInput!
}

input ClubWhereInput {
  AND: [ClubWhereInput!]
  NOT: [ClubWhereInput!]
  OR: [ClubWhereInput!]
  address: StringNullableFilter
  competitions: CompetitionListRelationFilter
  competitors: CompetitorListRelationFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  location: LocationRelationFilter
  locationId: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input ClubWhereUniqueInput {
  id: Int
}

type Comment {
  content: String!
  createdAt: DateTime!
  id: Int!
  scoresBoulder(cursor: ScoreBoulderWhereUniqueInput, distinct: [ScoreBoulderScalarFieldEnum!], orderBy: [ScoreBoulderOrderByInput!], skip: Int, take: Int, where: ScoreBoulderWhereInput): [ScoreBoulder!]!
  scoresLead(cursor: ScoreLeadWhereUniqueInput, distinct: [ScoreLeadScalarFieldEnum!], orderBy: [ScoreLeadOrderByInput!], skip: Int, take: Int, where: ScoreLeadWhereInput): [ScoreLead!]!
  scoresSpeed(cursor: ScoreSpeedWhereUniqueInput, distinct: [ScoreSpeedScalarFieldEnum!], orderBy: [ScoreSpeedOrderByInput!], skip: Int, take: Int, where: ScoreSpeedWhereInput): [ScoreSpeed!]!
  updatedAt: DateTime!
  user: User
  userId: Int
}

type CommentAvgAggregate {
  id: Float!
  userId: Float
}

type CommentCountAggregate {
  _all: Int!
  content: Int
  createdAt: Int
  id: Int!
  updatedAt: Int
  userId: Int
}

input CommentCreateInput {
  content: String!
  createdAt: DateTime
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCommentInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCommentInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCommentInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutCommentsInput
}

input CommentCreateManyInput {
  content: String!
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
  userId: Int
}

input CommentCreateManyUserInput {
  content: String!
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input CommentCreateManyUserInputEnvelope {
  data: [CommentCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input CommentCreateNestedManyWithoutUserInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  create: [CommentCreateWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
}

input CommentCreateNestedOneWithoutScoresBoulderInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutScoresBoulderInput
  create: CommentCreateWithoutScoresBoulderInput
}

input CommentCreateNestedOneWithoutScoresLeadInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutScoresLeadInput
  create: CommentCreateWithoutScoresLeadInput
}

input CommentCreateNestedOneWithoutScoresSpeedInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutScoresSpeedInput
  create: CommentCreateWithoutScoresSpeedInput
}

input CommentCreateOrConnectWithoutScoresBoulderInput {
  create: CommentCreateWithoutScoresBoulderInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutScoresLeadInput {
  create: CommentCreateWithoutScoresLeadInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutScoresSpeedInput {
  create: CommentCreateWithoutScoresSpeedInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateOrConnectWithoutUserInput {
  create: CommentCreateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentCreateWithoutScoresBoulderInput {
  content: String!
  createdAt: DateTime
  scoresLead: ScoreLeadCreateNestedManyWithoutCommentInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCommentInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutCommentsInput
}

input CommentCreateWithoutScoresLeadInput {
  content: String!
  createdAt: DateTime
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCommentInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCommentInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutCommentsInput
}

input CommentCreateWithoutScoresSpeedInput {
  content: String!
  createdAt: DateTime
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCommentInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCommentInput
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutCommentsInput
}

input CommentCreateWithoutUserInput {
  content: String!
  createdAt: DateTime
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCommentInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCommentInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCommentInput
  updatedAt: DateTime
}

type CommentGroupBy {
  avg: CommentAvgAggregate
  content: String!
  count: CommentCountAggregate
  createdAt: DateTime!
  id: Int!
  max: CommentMaxAggregate
  min: CommentMinAggregate
  sum: CommentSumAggregate
  updatedAt: DateTime!
  userId: Int
}

input CommentListRelationFilter {
  every: CommentWhereInput
  none: CommentWhereInput
  some: CommentWhereInput
}

type CommentMaxAggregate {
  content: String
  createdAt: DateTime
  id: Int!
  updatedAt: DateTime
  userId: Int
}

type CommentMinAggregate {
  content: String
  createdAt: DateTime
  id: Int!
  updatedAt: DateTime
  userId: Int
}

input CommentOrderByInput {
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input CommentRelationFilter {
  is: CommentWhereInput
  isNot: CommentWhereInput
}

enum CommentScalarFieldEnum {
  content
  createdAt
  id
  updatedAt
  userId
}

input CommentScalarWhereInput {
  AND: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  userId: IntNullableFilter
}

input CommentScalarWhereWithAggregatesInput {
  AND: [CommentScalarWhereWithAggregatesInput!]
  NOT: [CommentScalarWhereWithAggregatesInput!]
  OR: [CommentScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntNullableWithAggregatesFilter
}

type CommentSumAggregate {
  id: Int!
  userId: Int
}

input CommentUpdateInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCommentInput
  scoresLead: ScoreLeadUpdateManyWithoutCommentInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCommentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutCommentsInput
}

input CommentUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpdateManyWithWhereWithoutUserInput {
  data: CommentUpdateManyMutationInput!
  where: CommentScalarWhereInput!
}

input CommentUpdateManyWithoutUserInput {
  connect: [CommentWhereUniqueInput!]
  connectOrCreate: [CommentCreateOrConnectWithoutUserInput!]
  create: [CommentCreateWithoutUserInput!]
  createMany: CommentCreateManyUserInputEnvelope
  delete: [CommentWhereUniqueInput!]
  deleteMany: [CommentScalarWhereInput!]
  disconnect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [CommentUpdateManyWithWhereWithoutUserInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutUserInput!]
}

input CommentUpdateOneWithoutScoresBoulderInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutScoresBoulderInput
  create: CommentCreateWithoutScoresBoulderInput
  delete: Boolean
  disconnect: Boolean
  update: CommentUpdateWithoutScoresBoulderInput
  upsert: CommentUpsertWithoutScoresBoulderInput
}

input CommentUpdateOneWithoutScoresLeadInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutScoresLeadInput
  create: CommentCreateWithoutScoresLeadInput
  delete: Boolean
  disconnect: Boolean
  update: CommentUpdateWithoutScoresLeadInput
  upsert: CommentUpsertWithoutScoresLeadInput
}

input CommentUpdateOneWithoutScoresSpeedInput {
  connect: CommentWhereUniqueInput
  connectOrCreate: CommentCreateOrConnectWithoutScoresSpeedInput
  create: CommentCreateWithoutScoresSpeedInput
  delete: Boolean
  disconnect: Boolean
  update: CommentUpdateWithoutScoresSpeedInput
  upsert: CommentUpsertWithoutScoresSpeedInput
}

input CommentUpdateWithWhereUniqueWithoutUserInput {
  data: CommentUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentUpdateWithoutScoresBoulderInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  scoresLead: ScoreLeadUpdateManyWithoutCommentInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCommentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutScoresLeadInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCommentInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCommentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutScoresSpeedInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCommentInput
  scoresLead: ScoreLeadUpdateManyWithoutCommentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutUserInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCommentInput
  scoresLead: ScoreLeadUpdateManyWithoutCommentInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCommentInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CommentUpsertWithWhereUniqueWithoutUserInput {
  create: CommentCreateWithoutUserInput!
  update: CommentUpdateWithoutUserInput!
  where: CommentWhereUniqueInput!
}

input CommentUpsertWithoutScoresBoulderInput {
  create: CommentCreateWithoutScoresBoulderInput!
  update: CommentUpdateWithoutScoresBoulderInput!
}

input CommentUpsertWithoutScoresLeadInput {
  create: CommentCreateWithoutScoresLeadInput!
  update: CommentUpdateWithoutScoresLeadInput!
}

input CommentUpsertWithoutScoresSpeedInput {
  create: CommentCreateWithoutScoresSpeedInput!
  update: CommentUpdateWithoutScoresSpeedInput!
}

input CommentWhereInput {
  AND: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  scoresBoulder: ScoreBoulderListRelationFilter
  scoresLead: ScoreLeadListRelationFilter
  scoresSpeed: ScoreSpeedListRelationFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntNullableFilter
}

input CommentWhereUniqueInput {
  id: Int
}

type Competition {
  active: Boolean!
  address: String!
  club: Club!
  clubId: Int!
  compType: CompetitionType!
  compTypeId: Int!
  createdAt: DateTime!
  description: String!
  endDate: DateTime!
  id: Int!
  location: Location!
  locationId: Int!
  name: String!
  registrations(cursor: RegistrationWhereUniqueInput, distinct: [RegistrationScalarFieldEnum!], orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): [Registration!]!
  results(cursor: ResultWhereUniqueInput, distinct: [ResultScalarFieldEnum!], orderBy: [ResultOrderByInput!], skip: Int, take: Int, where: ResultWhereInput): [Result!]!
  routes(cursor: RouteWhereUniqueInput, distinct: [RouteScalarFieldEnum!], orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): [Route!]!
  season: Season!
  seasonId: Int!
  startDate: DateTime!
  startLists(cursor: StartListWhereUniqueInput, distinct: [StartListScalarFieldEnum!], orderBy: [StartListOrderByInput!], skip: Int, take: Int, where: StartListWhereInput): [StartList!]!
  updatedAt: DateTime!
}

type CompetitionAvgAggregate {
  clubId: Float!
  compTypeId: Float!
  id: Float!
  locationId: Float!
  seasonId: Float!
}

type CompetitionCountAggregate {
  _all: Int!
  active: Int
  address: Int
  clubId: Int!
  compTypeId: Int!
  createdAt: Int
  description: Int
  endDate: Int
  id: Int!
  locationId: Int!
  name: Int
  seasonId: Int!
  startDate: Int
  updatedAt: Int
}

input CompetitionCreateInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  results: ResultCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateManyClubInput {
  active: Boolean
  address: String!
  compTypeId: Int!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  id: Int
  locationId: Int!
  name: String!
  seasonId: Int!
  startDate: DateTime!
  updatedAt: DateTime
}

input CompetitionCreateManyClubInputEnvelope {
  data: [CompetitionCreateManyClubInput!]!
  skipDuplicates: Boolean
}

input CompetitionCreateManyCompTypeInput {
  active: Boolean
  address: String!
  clubId: Int!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  id: Int
  locationId: Int!
  name: String!
  seasonId: Int!
  startDate: DateTime!
  updatedAt: DateTime
}

input CompetitionCreateManyCompTypeInputEnvelope {
  data: [CompetitionCreateManyCompTypeInput!]!
  skipDuplicates: Boolean
}

input CompetitionCreateManyInput {
  active: Boolean
  address: String!
  clubId: Int!
  compTypeId: Int!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  id: Int
  locationId: Int!
  name: String!
  seasonId: Int!
  startDate: DateTime!
  updatedAt: DateTime
}

input CompetitionCreateManyLocationInput {
  active: Boolean
  address: String!
  clubId: Int!
  compTypeId: Int!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  id: Int
  name: String!
  seasonId: Int!
  startDate: DateTime!
  updatedAt: DateTime
}

input CompetitionCreateManyLocationInputEnvelope {
  data: [CompetitionCreateManyLocationInput!]!
  skipDuplicates: Boolean
}

input CompetitionCreateManySeasonInput {
  active: Boolean
  address: String!
  clubId: Int!
  compTypeId: Int!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  id: Int
  locationId: Int!
  name: String!
  startDate: DateTime!
  updatedAt: DateTime
}

input CompetitionCreateManySeasonInputEnvelope {
  data: [CompetitionCreateManySeasonInput!]!
  skipDuplicates: Boolean
}

input CompetitionCreateNestedManyWithoutClubInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutClubInput!]
  create: [CompetitionCreateWithoutClubInput!]
  createMany: CompetitionCreateManyClubInputEnvelope
}

input CompetitionCreateNestedManyWithoutCompTypeInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutCompTypeInput!]
  create: [CompetitionCreateWithoutCompTypeInput!]
  createMany: CompetitionCreateManyCompTypeInputEnvelope
}

input CompetitionCreateNestedManyWithoutLocationInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutLocationInput!]
  create: [CompetitionCreateWithoutLocationInput!]
  createMany: CompetitionCreateManyLocationInputEnvelope
}

input CompetitionCreateNestedManyWithoutSeasonInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutSeasonInput!]
  create: [CompetitionCreateWithoutSeasonInput!]
  createMany: CompetitionCreateManySeasonInputEnvelope
}

input CompetitionCreateNestedOneWithoutRegistrationsInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutRegistrationsInput
  create: CompetitionCreateWithoutRegistrationsInput
}

input CompetitionCreateNestedOneWithoutResultsInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutResultsInput
  create: CompetitionCreateWithoutResultsInput
}

input CompetitionCreateNestedOneWithoutRoutesInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutRoutesInput
  create: CompetitionCreateWithoutRoutesInput
}

input CompetitionCreateNestedOneWithoutStartListsInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutStartListsInput
  create: CompetitionCreateWithoutStartListsInput
}

input CompetitionCreateOrConnectWithoutClubInput {
  create: CompetitionCreateWithoutClubInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateOrConnectWithoutCompTypeInput {
  create: CompetitionCreateWithoutCompTypeInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateOrConnectWithoutLocationInput {
  create: CompetitionCreateWithoutLocationInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateOrConnectWithoutRegistrationsInput {
  create: CompetitionCreateWithoutRegistrationsInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateOrConnectWithoutResultsInput {
  create: CompetitionCreateWithoutResultsInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateOrConnectWithoutRoutesInput {
  create: CompetitionCreateWithoutRoutesInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateOrConnectWithoutSeasonInput {
  create: CompetitionCreateWithoutSeasonInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateOrConnectWithoutStartListsInput {
  create: CompetitionCreateWithoutStartListsInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionCreateWithoutClubInput {
  active: Boolean
  address: String!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  results: ResultCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateWithoutCompTypeInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  results: ResultCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateWithoutLocationInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  results: ResultCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateWithoutRegistrationsInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  results: ResultCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateWithoutResultsInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateWithoutRoutesInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  results: ResultCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateWithoutSeasonInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  results: ResultCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  startDate: DateTime!
  startLists: StartListCreateNestedManyWithoutCompetitionInput
  updatedAt: DateTime
}

input CompetitionCreateWithoutStartListsInput {
  active: Boolean
  address: String!
  club: ClubCreateNestedOneWithoutCompetitionsInput!
  compType: CompetitionTypeCreateNestedOneWithoutCompetitionsInput!
  createdAt: DateTime
  description: String!
  endDate: DateTime!
  location: LocationCreateNestedOneWithoutCompetitionsInput!
  name: String!
  registrations: RegistrationCreateNestedManyWithoutCompetitionInput
  results: ResultCreateNestedManyWithoutCompetitionInput
  routes: RouteCreateNestedManyWithoutCompetitionInput
  season: SeasonCreateNestedOneWithoutCompetitionsInput!
  startDate: DateTime!
  updatedAt: DateTime
}

type CompetitionGroupBy {
  active: Boolean!
  address: String!
  avg: CompetitionAvgAggregate
  clubId: Int!
  compTypeId: Int!
  count: CompetitionCountAggregate
  createdAt: DateTime!
  description: String!
  endDate: DateTime!
  id: Int!
  locationId: Int!
  max: CompetitionMaxAggregate
  min: CompetitionMinAggregate
  name: String!
  seasonId: Int!
  startDate: DateTime!
  sum: CompetitionSumAggregate
  updatedAt: DateTime!
}

input CompetitionListRelationFilter {
  every: CompetitionWhereInput
  none: CompetitionWhereInput
  some: CompetitionWhereInput
}

type CompetitionMaxAggregate {
  active: Boolean
  address: String
  clubId: Int!
  compTypeId: Int!
  createdAt: DateTime
  description: String
  endDate: DateTime
  id: Int!
  locationId: Int!
  name: String
  seasonId: Int!
  startDate: DateTime
  updatedAt: DateTime
}

type CompetitionMinAggregate {
  active: Boolean
  address: String
  clubId: Int!
  compTypeId: Int!
  createdAt: DateTime
  description: String
  endDate: DateTime
  id: Int!
  locationId: Int!
  name: String
  seasonId: Int!
  startDate: DateTime
  updatedAt: DateTime
}

input CompetitionOrderByInput {
  active: SortOrder
  address: SortOrder
  clubId: SortOrder
  compTypeId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  endDate: SortOrder
  id: SortOrder
  locationId: SortOrder
  name: SortOrder
  seasonId: SortOrder
  startDate: SortOrder
  updatedAt: SortOrder
}

input CompetitionRelationFilter {
  is: CompetitionWhereInput
  isNot: CompetitionWhereInput
}

enum CompetitionScalarFieldEnum {
  active
  address
  clubId
  compTypeId
  createdAt
  description
  endDate
  id
  locationId
  name
  seasonId
  startDate
  updatedAt
}

input CompetitionScalarWhereInput {
  AND: [CompetitionScalarWhereInput!]
  NOT: [CompetitionScalarWhereInput!]
  OR: [CompetitionScalarWhereInput!]
  active: BoolFilter
  address: StringFilter
  clubId: IntFilter
  compTypeId: IntFilter
  createdAt: DateTimeFilter
  description: StringFilter
  endDate: DateTimeFilter
  id: IntFilter
  locationId: IntFilter
  name: StringFilter
  seasonId: IntFilter
  startDate: DateTimeFilter
  updatedAt: DateTimeFilter
}

input CompetitionScalarWhereWithAggregatesInput {
  AND: [CompetitionScalarWhereWithAggregatesInput!]
  NOT: [CompetitionScalarWhereWithAggregatesInput!]
  OR: [CompetitionScalarWhereWithAggregatesInput!]
  active: BoolWithAggregatesFilter
  address: StringWithAggregatesFilter
  clubId: IntWithAggregatesFilter
  compTypeId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  endDate: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  locationId: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  seasonId: IntWithAggregatesFilter
  startDate: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type CompetitionSumAggregate {
  clubId: Int!
  compTypeId: Int!
  id: Int!
  locationId: Int!
  seasonId: Int!
}

type CompetitionType {
  competitions(cursor: CompetitionWhereUniqueInput, distinct: [CompetitionScalarFieldEnum!], orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): [Competition!]!
  description: String
  id: Int!
  name: String!
}

type CompetitionTypeAvgAggregate {
  id: Float!
}

type CompetitionTypeCountAggregate {
  _all: Int!
  description: Int
  id: Int!
  name: Int
}

input CompetitionTypeCreateInput {
  competitions: CompetitionCreateNestedManyWithoutCompTypeInput
  description: String
  name: String!
}

input CompetitionTypeCreateManyInput {
  description: String
  id: Int
  name: String!
}

input CompetitionTypeCreateNestedOneWithoutCompetitionsInput {
  connect: CompetitionTypeWhereUniqueInput
  connectOrCreate: CompetitionTypeCreateOrConnectWithoutCompetitionsInput
  create: CompetitionTypeCreateWithoutCompetitionsInput
}

input CompetitionTypeCreateOrConnectWithoutCompetitionsInput {
  create: CompetitionTypeCreateWithoutCompetitionsInput!
  where: CompetitionTypeWhereUniqueInput!
}

input CompetitionTypeCreateWithoutCompetitionsInput {
  description: String
  name: String!
}

type CompetitionTypeGroupBy {
  avg: CompetitionTypeAvgAggregate
  count: CompetitionTypeCountAggregate
  description: String
  id: Int!
  max: CompetitionTypeMaxAggregate
  min: CompetitionTypeMinAggregate
  name: String!
  sum: CompetitionTypeSumAggregate
}

type CompetitionTypeMaxAggregate {
  description: String
  id: Int!
  name: String
}

type CompetitionTypeMinAggregate {
  description: String
  id: Int!
  name: String
}

input CompetitionTypeOrderByInput {
  description: SortOrder
  id: SortOrder
  name: SortOrder
}

input CompetitionTypeRelationFilter {
  is: CompetitionTypeWhereInput
  isNot: CompetitionTypeWhereInput
}

enum CompetitionTypeScalarFieldEnum {
  description
  id
  name
}

input CompetitionTypeScalarWhereWithAggregatesInput {
  AND: [CompetitionTypeScalarWhereWithAggregatesInput!]
  NOT: [CompetitionTypeScalarWhereWithAggregatesInput!]
  OR: [CompetitionTypeScalarWhereWithAggregatesInput!]
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CompetitionTypeSumAggregate {
  id: Int!
}

input CompetitionTypeUpdateInput {
  competitions: CompetitionUpdateManyWithoutCompTypeInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CompetitionTypeUpdateManyMutationInput {
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput {
  connect: CompetitionTypeWhereUniqueInput
  connectOrCreate: CompetitionTypeCreateOrConnectWithoutCompetitionsInput
  create: CompetitionTypeCreateWithoutCompetitionsInput
  update: CompetitionTypeUpdateWithoutCompetitionsInput
  upsert: CompetitionTypeUpsertWithoutCompetitionsInput
}

input CompetitionTypeUpdateWithoutCompetitionsInput {
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CompetitionTypeUpsertWithoutCompetitionsInput {
  create: CompetitionTypeCreateWithoutCompetitionsInput!
  update: CompetitionTypeUpdateWithoutCompetitionsInput!
}

input CompetitionTypeWhereInput {
  AND: [CompetitionTypeWhereInput!]
  NOT: [CompetitionTypeWhereInput!]
  OR: [CompetitionTypeWhereInput!]
  competitions: CompetitionListRelationFilter
  description: StringNullableFilter
  id: IntFilter
  name: StringFilter
}

input CompetitionTypeWhereUniqueInput {
  id: Int
}

input CompetitionUpdateInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  results: ResultUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateManyMutationInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  startDate: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateManyWithWhereWithoutClubInput {
  data: CompetitionUpdateManyMutationInput!
  where: CompetitionScalarWhereInput!
}

input CompetitionUpdateManyWithWhereWithoutCompTypeInput {
  data: CompetitionUpdateManyMutationInput!
  where: CompetitionScalarWhereInput!
}

input CompetitionUpdateManyWithWhereWithoutLocationInput {
  data: CompetitionUpdateManyMutationInput!
  where: CompetitionScalarWhereInput!
}

input CompetitionUpdateManyWithWhereWithoutSeasonInput {
  data: CompetitionUpdateManyMutationInput!
  where: CompetitionScalarWhereInput!
}

input CompetitionUpdateManyWithoutClubInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutClubInput!]
  create: [CompetitionCreateWithoutClubInput!]
  createMany: CompetitionCreateManyClubInputEnvelope
  delete: [CompetitionWhereUniqueInput!]
  deleteMany: [CompetitionScalarWhereInput!]
  disconnect: [CompetitionWhereUniqueInput!]
  set: [CompetitionWhereUniqueInput!]
  update: [CompetitionUpdateWithWhereUniqueWithoutClubInput!]
  updateMany: [CompetitionUpdateManyWithWhereWithoutClubInput!]
  upsert: [CompetitionUpsertWithWhereUniqueWithoutClubInput!]
}

input CompetitionUpdateManyWithoutCompTypeInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutCompTypeInput!]
  create: [CompetitionCreateWithoutCompTypeInput!]
  createMany: CompetitionCreateManyCompTypeInputEnvelope
  delete: [CompetitionWhereUniqueInput!]
  deleteMany: [CompetitionScalarWhereInput!]
  disconnect: [CompetitionWhereUniqueInput!]
  set: [CompetitionWhereUniqueInput!]
  update: [CompetitionUpdateWithWhereUniqueWithoutCompTypeInput!]
  updateMany: [CompetitionUpdateManyWithWhereWithoutCompTypeInput!]
  upsert: [CompetitionUpsertWithWhereUniqueWithoutCompTypeInput!]
}

input CompetitionUpdateManyWithoutLocationInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutLocationInput!]
  create: [CompetitionCreateWithoutLocationInput!]
  createMany: CompetitionCreateManyLocationInputEnvelope
  delete: [CompetitionWhereUniqueInput!]
  deleteMany: [CompetitionScalarWhereInput!]
  disconnect: [CompetitionWhereUniqueInput!]
  set: [CompetitionWhereUniqueInput!]
  update: [CompetitionUpdateWithWhereUniqueWithoutLocationInput!]
  updateMany: [CompetitionUpdateManyWithWhereWithoutLocationInput!]
  upsert: [CompetitionUpsertWithWhereUniqueWithoutLocationInput!]
}

input CompetitionUpdateManyWithoutSeasonInput {
  connect: [CompetitionWhereUniqueInput!]
  connectOrCreate: [CompetitionCreateOrConnectWithoutSeasonInput!]
  create: [CompetitionCreateWithoutSeasonInput!]
  createMany: CompetitionCreateManySeasonInputEnvelope
  delete: [CompetitionWhereUniqueInput!]
  deleteMany: [CompetitionScalarWhereInput!]
  disconnect: [CompetitionWhereUniqueInput!]
  set: [CompetitionWhereUniqueInput!]
  update: [CompetitionUpdateWithWhereUniqueWithoutSeasonInput!]
  updateMany: [CompetitionUpdateManyWithWhereWithoutSeasonInput!]
  upsert: [CompetitionUpsertWithWhereUniqueWithoutSeasonInput!]
}

input CompetitionUpdateOneRequiredWithoutRegistrationsInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutRegistrationsInput
  create: CompetitionCreateWithoutRegistrationsInput
  update: CompetitionUpdateWithoutRegistrationsInput
  upsert: CompetitionUpsertWithoutRegistrationsInput
}

input CompetitionUpdateOneRequiredWithoutResultsInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutResultsInput
  create: CompetitionCreateWithoutResultsInput
  update: CompetitionUpdateWithoutResultsInput
  upsert: CompetitionUpsertWithoutResultsInput
}

input CompetitionUpdateOneRequiredWithoutRoutesInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutRoutesInput
  create: CompetitionCreateWithoutRoutesInput
  update: CompetitionUpdateWithoutRoutesInput
  upsert: CompetitionUpsertWithoutRoutesInput
}

input CompetitionUpdateOneRequiredWithoutStartListsInput {
  connect: CompetitionWhereUniqueInput
  connectOrCreate: CompetitionCreateOrConnectWithoutStartListsInput
  create: CompetitionCreateWithoutStartListsInput
  update: CompetitionUpdateWithoutStartListsInput
  upsert: CompetitionUpsertWithoutStartListsInput
}

input CompetitionUpdateWithWhereUniqueWithoutClubInput {
  data: CompetitionUpdateWithoutClubInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpdateWithWhereUniqueWithoutCompTypeInput {
  data: CompetitionUpdateWithoutCompTypeInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpdateWithWhereUniqueWithoutLocationInput {
  data: CompetitionUpdateWithoutLocationInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpdateWithWhereUniqueWithoutSeasonInput {
  data: CompetitionUpdateWithoutSeasonInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpdateWithoutClubInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  results: ResultUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateWithoutCompTypeInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  results: ResultUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateWithoutLocationInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  results: ResultUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateWithoutRegistrationsInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  results: ResultUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateWithoutResultsInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateWithoutRoutesInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  results: ResultUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateWithoutSeasonInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  results: ResultUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  startDate: DateTimeFieldUpdateOperationsInput
  startLists: StartListUpdateManyWithoutCompetitionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpdateWithoutStartListsInput {
  active: BoolFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitionsInput
  compType: CompetitionTypeUpdateOneRequiredWithoutCompetitionsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitionsInput
  name: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitionInput
  results: ResultUpdateManyWithoutCompetitionInput
  routes: RouteUpdateManyWithoutCompetitionInput
  season: SeasonUpdateOneRequiredWithoutCompetitionsInput
  startDate: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitionUpsertWithWhereUniqueWithoutClubInput {
  create: CompetitionCreateWithoutClubInput!
  update: CompetitionUpdateWithoutClubInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpsertWithWhereUniqueWithoutCompTypeInput {
  create: CompetitionCreateWithoutCompTypeInput!
  update: CompetitionUpdateWithoutCompTypeInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpsertWithWhereUniqueWithoutLocationInput {
  create: CompetitionCreateWithoutLocationInput!
  update: CompetitionUpdateWithoutLocationInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpsertWithWhereUniqueWithoutSeasonInput {
  create: CompetitionCreateWithoutSeasonInput!
  update: CompetitionUpdateWithoutSeasonInput!
  where: CompetitionWhereUniqueInput!
}

input CompetitionUpsertWithoutRegistrationsInput {
  create: CompetitionCreateWithoutRegistrationsInput!
  update: CompetitionUpdateWithoutRegistrationsInput!
}

input CompetitionUpsertWithoutResultsInput {
  create: CompetitionCreateWithoutResultsInput!
  update: CompetitionUpdateWithoutResultsInput!
}

input CompetitionUpsertWithoutRoutesInput {
  create: CompetitionCreateWithoutRoutesInput!
  update: CompetitionUpdateWithoutRoutesInput!
}

input CompetitionUpsertWithoutStartListsInput {
  create: CompetitionCreateWithoutStartListsInput!
  update: CompetitionUpdateWithoutStartListsInput!
}

input CompetitionWhereInput {
  AND: [CompetitionWhereInput!]
  NOT: [CompetitionWhereInput!]
  OR: [CompetitionWhereInput!]
  active: BoolFilter
  address: StringFilter
  club: ClubRelationFilter
  clubId: IntFilter
  compType: CompetitionTypeRelationFilter
  compTypeId: IntFilter
  createdAt: DateTimeFilter
  description: StringFilter
  endDate: DateTimeFilter
  id: IntFilter
  location: LocationRelationFilter
  locationId: IntFilter
  name: StringFilter
  registrations: RegistrationListRelationFilter
  results: ResultListRelationFilter
  routes: RouteListRelationFilter
  season: SeasonRelationFilter
  seasonId: IntFilter
  startDate: DateTimeFilter
  startLists: StartListListRelationFilter
  updatedAt: DateTimeFilter
}

input CompetitionWhereUniqueInput {
  id: Int
}

type Competitor {
  address: String
  birdthDate: DateTime!
  category: Category!
  categoryId: Int!
  club: Club!
  clubId: Int!
  createdAt: DateTime!
  firstName: String!
  gender: Gender!
  id: Int!
  lastName: String!
  location: Location!
  locationId: Int!
  publicId: String!
  registrations(cursor: RegistrationWhereUniqueInput, distinct: [RegistrationScalarFieldEnum!], orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): [Registration!]!
  results(cursor: ResultWhereUniqueInput, distinct: [ResultScalarFieldEnum!], orderBy: [ResultOrderByInput!], skip: Int, take: Int, where: ResultWhereInput): [Result!]!
  scoresBoulder(cursor: ScoreBoulderWhereUniqueInput, distinct: [ScoreBoulderScalarFieldEnum!], orderBy: [ScoreBoulderOrderByInput!], skip: Int, take: Int, where: ScoreBoulderWhereInput): [ScoreBoulder!]!
  scoresLead(cursor: ScoreLeadWhereUniqueInput, distinct: [ScoreLeadScalarFieldEnum!], orderBy: [ScoreLeadOrderByInput!], skip: Int, take: Int, where: ScoreLeadWhereInput): [ScoreLead!]!
  scoresSpeed(cursor: ScoreSpeedWhereUniqueInput, distinct: [ScoreSpeedScalarFieldEnum!], orderBy: [ScoreSpeedOrderByInput!], skip: Int, take: Int, where: ScoreSpeedWhereInput): [ScoreSpeed!]!
  startLists(cursor: StartListWhereUniqueInput, distinct: [StartListScalarFieldEnum!], orderBy: [StartListOrderByInput!], skip: Int, take: Int, where: StartListWhereInput): [StartList!]!
  updatedAt: DateTime!
}

type CompetitorAvgAggregate {
  categoryId: Float!
  clubId: Float!
  id: Float!
  locationId: Float!
}

type CompetitorCountAggregate {
  _all: Int!
  address: Int
  birdthDate: Int
  categoryId: Int!
  clubId: Int!
  createdAt: Int
  firstName: Int
  gender: Int
  id: Int!
  lastName: Int
  locationId: Int!
  publicId: Int
  updatedAt: Int
}

input CompetitorCreateInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateManyCategoryInput {
  address: String
  birdthDate: DateTime!
  clubId: Int!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  id: Int
  lastName: String!
  locationId: Int!
  publicId: String
  updatedAt: DateTime
}

input CompetitorCreateManyCategoryInputEnvelope {
  data: [CompetitorCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input CompetitorCreateManyClubInput {
  address: String
  birdthDate: DateTime!
  categoryId: Int!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  id: Int
  lastName: String!
  locationId: Int!
  publicId: String
  updatedAt: DateTime
}

input CompetitorCreateManyClubInputEnvelope {
  data: [CompetitorCreateManyClubInput!]!
  skipDuplicates: Boolean
}

input CompetitorCreateManyInput {
  address: String
  birdthDate: DateTime!
  categoryId: Int!
  clubId: Int!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  id: Int
  lastName: String!
  locationId: Int!
  publicId: String
  updatedAt: DateTime
}

input CompetitorCreateManyLocationInput {
  address: String
  birdthDate: DateTime!
  categoryId: Int!
  clubId: Int!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  id: Int
  lastName: String!
  publicId: String
  updatedAt: DateTime
}

input CompetitorCreateManyLocationInputEnvelope {
  data: [CompetitorCreateManyLocationInput!]!
  skipDuplicates: Boolean
}

input CompetitorCreateNestedManyWithoutCategoryInput {
  connect: [CompetitorWhereUniqueInput!]
  connectOrCreate: [CompetitorCreateOrConnectWithoutCategoryInput!]
  create: [CompetitorCreateWithoutCategoryInput!]
  createMany: CompetitorCreateManyCategoryInputEnvelope
}

input CompetitorCreateNestedManyWithoutClubInput {
  connect: [CompetitorWhereUniqueInput!]
  connectOrCreate: [CompetitorCreateOrConnectWithoutClubInput!]
  create: [CompetitorCreateWithoutClubInput!]
  createMany: CompetitorCreateManyClubInputEnvelope
}

input CompetitorCreateNestedManyWithoutLocationInput {
  connect: [CompetitorWhereUniqueInput!]
  connectOrCreate: [CompetitorCreateOrConnectWithoutLocationInput!]
  create: [CompetitorCreateWithoutLocationInput!]
  createMany: CompetitorCreateManyLocationInputEnvelope
}

input CompetitorCreateNestedOneWithoutRegistrationsInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutRegistrationsInput
  create: CompetitorCreateWithoutRegistrationsInput
}

input CompetitorCreateNestedOneWithoutResultsInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutResultsInput
  create: CompetitorCreateWithoutResultsInput
}

input CompetitorCreateNestedOneWithoutScoresBoulderInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutScoresBoulderInput
  create: CompetitorCreateWithoutScoresBoulderInput
}

input CompetitorCreateNestedOneWithoutScoresLeadInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutScoresLeadInput
  create: CompetitorCreateWithoutScoresLeadInput
}

input CompetitorCreateNestedOneWithoutScoresSpeedInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutScoresSpeedInput
  create: CompetitorCreateWithoutScoresSpeedInput
}

input CompetitorCreateNestedOneWithoutStartListsInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutStartListsInput
  create: CompetitorCreateWithoutStartListsInput
}

input CompetitorCreateOrConnectWithoutCategoryInput {
  create: CompetitorCreateWithoutCategoryInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutClubInput {
  create: CompetitorCreateWithoutClubInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutLocationInput {
  create: CompetitorCreateWithoutLocationInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutRegistrationsInput {
  create: CompetitorCreateWithoutRegistrationsInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutResultsInput {
  create: CompetitorCreateWithoutResultsInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutScoresBoulderInput {
  create: CompetitorCreateWithoutScoresBoulderInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutScoresLeadInput {
  create: CompetitorCreateWithoutScoresLeadInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutScoresSpeedInput {
  create: CompetitorCreateWithoutScoresSpeedInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateOrConnectWithoutStartListsInput {
  create: CompetitorCreateWithoutStartListsInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorCreateWithoutCategoryInput {
  address: String
  birdthDate: DateTime!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutClubInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutLocationInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutRegistrationsInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutResultsInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutScoresBoulderInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutScoresLeadInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutScoresSpeedInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  startLists: StartListCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

input CompetitorCreateWithoutStartListsInput {
  address: String
  birdthDate: DateTime!
  category: CategoryCreateNestedOneWithoutCompetitorsInput!
  club: ClubCreateNestedOneWithoutCompetitorsInput!
  createdAt: DateTime
  firstName: String!
  gender: Gender!
  lastName: String!
  location: LocationCreateNestedOneWithoutCompetitorsInput!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutCompetitorInput
  results: ResultCreateNestedManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderCreateNestedManyWithoutCompetitorInput
  scoresLead: ScoreLeadCreateNestedManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedCreateNestedManyWithoutCompetitorInput
  updatedAt: DateTime
}

type CompetitorGroupBy {
  address: String
  avg: CompetitorAvgAggregate
  birdthDate: DateTime!
  categoryId: Int!
  clubId: Int!
  count: CompetitorCountAggregate
  createdAt: DateTime!
  firstName: String!
  gender: Gender!
  id: Int!
  lastName: String!
  locationId: Int!
  max: CompetitorMaxAggregate
  min: CompetitorMinAggregate
  publicId: String!
  sum: CompetitorSumAggregate
  updatedAt: DateTime!
}

input CompetitorListRelationFilter {
  every: CompetitorWhereInput
  none: CompetitorWhereInput
  some: CompetitorWhereInput
}

type CompetitorMaxAggregate {
  address: String
  birdthDate: DateTime
  categoryId: Int!
  clubId: Int!
  createdAt: DateTime
  firstName: String
  gender: Gender
  id: Int!
  lastName: String
  locationId: Int!
  publicId: String
  updatedAt: DateTime
}

type CompetitorMinAggregate {
  address: String
  birdthDate: DateTime
  categoryId: Int!
  clubId: Int!
  createdAt: DateTime
  firstName: String
  gender: Gender
  id: Int!
  lastName: String
  locationId: Int!
  publicId: String
  updatedAt: DateTime
}

input CompetitorOrderByInput {
  address: SortOrder
  birdthDate: SortOrder
  categoryId: SortOrder
  clubId: SortOrder
  createdAt: SortOrder
  firstName: SortOrder
  gender: SortOrder
  id: SortOrder
  lastName: SortOrder
  locationId: SortOrder
  publicId: SortOrder
  updatedAt: SortOrder
}

input CompetitorRelationFilter {
  is: CompetitorWhereInput
  isNot: CompetitorWhereInput
}

enum CompetitorScalarFieldEnum {
  address
  birdthDate
  categoryId
  clubId
  createdAt
  firstName
  gender
  id
  lastName
  locationId
  publicId
  updatedAt
}

input CompetitorScalarWhereInput {
  AND: [CompetitorScalarWhereInput!]
  NOT: [CompetitorScalarWhereInput!]
  OR: [CompetitorScalarWhereInput!]
  address: StringNullableFilter
  birdthDate: DateTimeFilter
  categoryId: IntFilter
  clubId: IntFilter
  createdAt: DateTimeFilter
  firstName: StringFilter
  gender: EnumGenderFilter
  id: IntFilter
  lastName: StringFilter
  locationId: IntFilter
  publicId: StringFilter
  updatedAt: DateTimeFilter
}

input CompetitorScalarWhereWithAggregatesInput {
  AND: [CompetitorScalarWhereWithAggregatesInput!]
  NOT: [CompetitorScalarWhereWithAggregatesInput!]
  OR: [CompetitorScalarWhereWithAggregatesInput!]
  address: StringNullableWithAggregatesFilter
  birdthDate: DateTimeWithAggregatesFilter
  categoryId: IntWithAggregatesFilter
  clubId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  gender: EnumGenderWithAggregatesFilter
  id: IntWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  locationId: IntWithAggregatesFilter
  publicId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type CompetitorSumAggregate {
  categoryId: Int!
  clubId: Int!
  id: Int!
  locationId: Int!
}

input CompetitorUpdateInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateManyMutationInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateManyWithWhereWithoutCategoryInput {
  data: CompetitorUpdateManyMutationInput!
  where: CompetitorScalarWhereInput!
}

input CompetitorUpdateManyWithWhereWithoutClubInput {
  data: CompetitorUpdateManyMutationInput!
  where: CompetitorScalarWhereInput!
}

input CompetitorUpdateManyWithWhereWithoutLocationInput {
  data: CompetitorUpdateManyMutationInput!
  where: CompetitorScalarWhereInput!
}

input CompetitorUpdateManyWithoutCategoryInput {
  connect: [CompetitorWhereUniqueInput!]
  connectOrCreate: [CompetitorCreateOrConnectWithoutCategoryInput!]
  create: [CompetitorCreateWithoutCategoryInput!]
  createMany: CompetitorCreateManyCategoryInputEnvelope
  delete: [CompetitorWhereUniqueInput!]
  deleteMany: [CompetitorScalarWhereInput!]
  disconnect: [CompetitorWhereUniqueInput!]
  set: [CompetitorWhereUniqueInput!]
  update: [CompetitorUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [CompetitorUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [CompetitorUpsertWithWhereUniqueWithoutCategoryInput!]
}

input CompetitorUpdateManyWithoutClubInput {
  connect: [CompetitorWhereUniqueInput!]
  connectOrCreate: [CompetitorCreateOrConnectWithoutClubInput!]
  create: [CompetitorCreateWithoutClubInput!]
  createMany: CompetitorCreateManyClubInputEnvelope
  delete: [CompetitorWhereUniqueInput!]
  deleteMany: [CompetitorScalarWhereInput!]
  disconnect: [CompetitorWhereUniqueInput!]
  set: [CompetitorWhereUniqueInput!]
  update: [CompetitorUpdateWithWhereUniqueWithoutClubInput!]
  updateMany: [CompetitorUpdateManyWithWhereWithoutClubInput!]
  upsert: [CompetitorUpsertWithWhereUniqueWithoutClubInput!]
}

input CompetitorUpdateManyWithoutLocationInput {
  connect: [CompetitorWhereUniqueInput!]
  connectOrCreate: [CompetitorCreateOrConnectWithoutLocationInput!]
  create: [CompetitorCreateWithoutLocationInput!]
  createMany: CompetitorCreateManyLocationInputEnvelope
  delete: [CompetitorWhereUniqueInput!]
  deleteMany: [CompetitorScalarWhereInput!]
  disconnect: [CompetitorWhereUniqueInput!]
  set: [CompetitorWhereUniqueInput!]
  update: [CompetitorUpdateWithWhereUniqueWithoutLocationInput!]
  updateMany: [CompetitorUpdateManyWithWhereWithoutLocationInput!]
  upsert: [CompetitorUpsertWithWhereUniqueWithoutLocationInput!]
}

input CompetitorUpdateOneRequiredWithoutRegistrationsInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutRegistrationsInput
  create: CompetitorCreateWithoutRegistrationsInput
  update: CompetitorUpdateWithoutRegistrationsInput
  upsert: CompetitorUpsertWithoutRegistrationsInput
}

input CompetitorUpdateOneRequiredWithoutResultsInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutResultsInput
  create: CompetitorCreateWithoutResultsInput
  update: CompetitorUpdateWithoutResultsInput
  upsert: CompetitorUpsertWithoutResultsInput
}

input CompetitorUpdateOneRequiredWithoutScoresBoulderInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutScoresBoulderInput
  create: CompetitorCreateWithoutScoresBoulderInput
  update: CompetitorUpdateWithoutScoresBoulderInput
  upsert: CompetitorUpsertWithoutScoresBoulderInput
}

input CompetitorUpdateOneRequiredWithoutScoresLeadInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutScoresLeadInput
  create: CompetitorCreateWithoutScoresLeadInput
  update: CompetitorUpdateWithoutScoresLeadInput
  upsert: CompetitorUpsertWithoutScoresLeadInput
}

input CompetitorUpdateOneRequiredWithoutScoresSpeedInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutScoresSpeedInput
  create: CompetitorCreateWithoutScoresSpeedInput
  update: CompetitorUpdateWithoutScoresSpeedInput
  upsert: CompetitorUpsertWithoutScoresSpeedInput
}

input CompetitorUpdateOneRequiredWithoutStartListsInput {
  connect: CompetitorWhereUniqueInput
  connectOrCreate: CompetitorCreateOrConnectWithoutStartListsInput
  create: CompetitorCreateWithoutStartListsInput
  update: CompetitorUpdateWithoutStartListsInput
  upsert: CompetitorUpsertWithoutStartListsInput
}

input CompetitorUpdateWithWhereUniqueWithoutCategoryInput {
  data: CompetitorUpdateWithoutCategoryInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorUpdateWithWhereUniqueWithoutClubInput {
  data: CompetitorUpdateWithoutClubInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorUpdateWithWhereUniqueWithoutLocationInput {
  data: CompetitorUpdateWithoutLocationInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorUpdateWithoutCategoryInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutClubInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutLocationInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutRegistrationsInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutResultsInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutScoresBoulderInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutScoresLeadInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutScoresSpeedInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  startLists: StartListUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpdateWithoutStartListsInput {
  address: NullableStringFieldUpdateOperationsInput
  birdthDate: DateTimeFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutCompetitorsInput
  club: ClubUpdateOneRequiredWithoutCompetitorsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  gender: EnumGenderFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneRequiredWithoutCompetitorsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutCompetitorInput
  results: ResultUpdateManyWithoutCompetitorInput
  scoresBoulder: ScoreBoulderUpdateManyWithoutCompetitorInput
  scoresLead: ScoreLeadUpdateManyWithoutCompetitorInput
  scoresSpeed: ScoreSpeedUpdateManyWithoutCompetitorInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CompetitorUpsertWithWhereUniqueWithoutCategoryInput {
  create: CompetitorCreateWithoutCategoryInput!
  update: CompetitorUpdateWithoutCategoryInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorUpsertWithWhereUniqueWithoutClubInput {
  create: CompetitorCreateWithoutClubInput!
  update: CompetitorUpdateWithoutClubInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorUpsertWithWhereUniqueWithoutLocationInput {
  create: CompetitorCreateWithoutLocationInput!
  update: CompetitorUpdateWithoutLocationInput!
  where: CompetitorWhereUniqueInput!
}

input CompetitorUpsertWithoutRegistrationsInput {
  create: CompetitorCreateWithoutRegistrationsInput!
  update: CompetitorUpdateWithoutRegistrationsInput!
}

input CompetitorUpsertWithoutResultsInput {
  create: CompetitorCreateWithoutResultsInput!
  update: CompetitorUpdateWithoutResultsInput!
}

input CompetitorUpsertWithoutScoresBoulderInput {
  create: CompetitorCreateWithoutScoresBoulderInput!
  update: CompetitorUpdateWithoutScoresBoulderInput!
}

input CompetitorUpsertWithoutScoresLeadInput {
  create: CompetitorCreateWithoutScoresLeadInput!
  update: CompetitorUpdateWithoutScoresLeadInput!
}

input CompetitorUpsertWithoutScoresSpeedInput {
  create: CompetitorCreateWithoutScoresSpeedInput!
  update: CompetitorUpdateWithoutScoresSpeedInput!
}

input CompetitorUpsertWithoutStartListsInput {
  create: CompetitorCreateWithoutStartListsInput!
  update: CompetitorUpdateWithoutStartListsInput!
}

input CompetitorWhereInput {
  AND: [CompetitorWhereInput!]
  NOT: [CompetitorWhereInput!]
  OR: [CompetitorWhereInput!]
  address: StringNullableFilter
  birdthDate: DateTimeFilter
  category: CategoryRelationFilter
  categoryId: IntFilter
  club: ClubRelationFilter
  clubId: IntFilter
  createdAt: DateTimeFilter
  firstName: StringFilter
  gender: EnumGenderFilter
  id: IntFilter
  lastName: StringFilter
  location: LocationRelationFilter
  locationId: IntFilter
  publicId: StringFilter
  registrations: RegistrationListRelationFilter
  results: ResultListRelationFilter
  scoresBoulder: ScoreBoulderListRelationFilter
  scoresLead: ScoreLeadListRelationFilter
  scoresSpeed: ScoreSpeedListRelationFilter
  startLists: StartListListRelationFilter
  updatedAt: DateTimeFilter
}

input CompetitorWhereUniqueInput {
  id: Int
  publicId: String
}

type Country {
  id: Int!
  locations(cursor: LocationWhereUniqueInput, distinct: [LocationScalarFieldEnum!], orderBy: [LocationOrderByInput!], skip: Int, take: Int, where: LocationWhereInput): [Location!]!
  name: String!
}

type CountryAvgAggregate {
  id: Float!
}

type CountryCountAggregate {
  _all: Int!
  id: Int!
  name: Int
}

input CountryCreateInput {
  locations: LocationCreateNestedManyWithoutCountryInput
  name: String!
}

input CountryCreateManyInput {
  id: Int
  name: String!
}

input CountryCreateNestedOneWithoutLocationsInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutLocationsInput
  create: CountryCreateWithoutLocationsInput
}

input CountryCreateOrConnectWithoutLocationsInput {
  create: CountryCreateWithoutLocationsInput!
  where: CountryWhereUniqueInput!
}

input CountryCreateWithoutLocationsInput {
  name: String!
}

type CountryGroupBy {
  avg: CountryAvgAggregate
  count: CountryCountAggregate
  id: Int!
  max: CountryMaxAggregate
  min: CountryMinAggregate
  name: String!
  sum: CountrySumAggregate
}

type CountryMaxAggregate {
  id: Int!
  name: String
}

type CountryMinAggregate {
  id: Int!
  name: String
}

input CountryOrderByInput {
  id: SortOrder
  name: SortOrder
}

input CountryRelationFilter {
  is: CountryWhereInput
  isNot: CountryWhereInput
}

enum CountryScalarFieldEnum {
  id
  name
}

input CountryScalarWhereWithAggregatesInput {
  AND: [CountryScalarWhereWithAggregatesInput!]
  NOT: [CountryScalarWhereWithAggregatesInput!]
  OR: [CountryScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type CountrySumAggregate {
  id: Int!
}

input CountryUpdateInput {
  locations: LocationUpdateManyWithoutCountryInput
  name: StringFieldUpdateOperationsInput
}

input CountryUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input CountryUpdateOneRequiredWithoutLocationsInput {
  connect: CountryWhereUniqueInput
  connectOrCreate: CountryCreateOrConnectWithoutLocationsInput
  create: CountryCreateWithoutLocationsInput
  update: CountryUpdateWithoutLocationsInput
  upsert: CountryUpsertWithoutLocationsInput
}

input CountryUpdateWithoutLocationsInput {
  name: StringFieldUpdateOperationsInput
}

input CountryUpsertWithoutLocationsInput {
  create: CountryCreateWithoutLocationsInput!
  update: CountryUpdateWithoutLocationsInput!
}

input CountryWhereInput {
  AND: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  id: IntFilter
  locations: LocationListRelationFilter
  name: StringFilter
}

input CountryWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  count: NestedIntFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeFilter
  min: NestedDateTimeFilter
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input EnumGenderFieldUpdateOperationsInput {
  set: Gender
}

input EnumGenderFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderFilter
  notIn: [Gender!]
}

input EnumGenderWithAggregatesFilter {
  count: NestedIntFilter
  equals: Gender
  in: [Gender!]
  max: NestedEnumGenderFilter
  min: NestedEnumGenderFilter
  not: NestedEnumGenderWithAggregatesFilter
  notIn: [Gender!]
}

input EnumRouteTypeFieldUpdateOperationsInput {
  set: RouteType
}

input EnumRouteTypeFilter {
  equals: RouteType
  in: [RouteType!]
  not: NestedEnumRouteTypeFilter
  notIn: [RouteType!]
}

input EnumRouteTypeWithAggregatesFilter {
  count: NestedIntFilter
  equals: RouteType
  in: [RouteType!]
  max: NestedEnumRouteTypeFilter
  min: NestedEnumRouteTypeFilter
  not: NestedEnumRouteTypeWithAggregatesFilter
  notIn: [RouteType!]
}

input EnumUserRoleFieldUpdateOperationsInput {
  set: UserRole
}

input EnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input EnumUserRoleWithAggregatesFilter {
  count: NestedIntFilter
  equals: UserRole
  in: [UserRole!]
  max: NestedEnumUserRoleFilter
  min: NestedEnumUserRoleFilter
  not: NestedEnumUserRoleWithAggregatesFilter
  notIn: [UserRole!]
}

input FindStartListInput {
  competitionId: Float!
  startNumber: Float!
}

enum Gender {
  FEMALE
  MALE
}

type Grade {
  id: Int!
  name: String!
  routes(cursor: RouteWhereUniqueInput, distinct: [RouteScalarFieldEnum!], orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): [Route!]!
}

type GradeAvgAggregate {
  id: Float!
}

type GradeCountAggregate {
  _all: Int!
  id: Int!
  name: Int
}

input GradeCreateInput {
  name: String!
  routes: RouteCreateNestedManyWithoutGradeInput
}

input GradeCreateManyInput {
  id: Int
  name: String!
}

input GradeCreateNestedOneWithoutRoutesInput {
  connect: GradeWhereUniqueInput
  connectOrCreate: GradeCreateOrConnectWithoutRoutesInput
  create: GradeCreateWithoutRoutesInput
}

input GradeCreateOrConnectWithoutRoutesInput {
  create: GradeCreateWithoutRoutesInput!
  where: GradeWhereUniqueInput!
}

input GradeCreateWithoutRoutesInput {
  name: String!
}

type GradeGroupBy {
  avg: GradeAvgAggregate
  count: GradeCountAggregate
  id: Int!
  max: GradeMaxAggregate
  min: GradeMinAggregate
  name: String!
  sum: GradeSumAggregate
}

type GradeMaxAggregate {
  id: Int!
  name: String
}

type GradeMinAggregate {
  id: Int!
  name: String
}

input GradeOrderByInput {
  id: SortOrder
  name: SortOrder
}

input GradeRelationFilter {
  is: GradeWhereInput
  isNot: GradeWhereInput
}

enum GradeScalarFieldEnum {
  id
  name
}

input GradeScalarWhereWithAggregatesInput {
  AND: [GradeScalarWhereWithAggregatesInput!]
  NOT: [GradeScalarWhereWithAggregatesInput!]
  OR: [GradeScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type GradeSumAggregate {
  id: Int!
}

input GradeUpdateInput {
  name: StringFieldUpdateOperationsInput
  routes: RouteUpdateManyWithoutGradeInput
}

input GradeUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input GradeUpdateOneRequiredWithoutRoutesInput {
  connect: GradeWhereUniqueInput
  connectOrCreate: GradeCreateOrConnectWithoutRoutesInput
  create: GradeCreateWithoutRoutesInput
  update: GradeUpdateWithoutRoutesInput
  upsert: GradeUpsertWithoutRoutesInput
}

input GradeUpdateWithoutRoutesInput {
  name: StringFieldUpdateOperationsInput
}

input GradeUpsertWithoutRoutesInput {
  create: GradeCreateWithoutRoutesInput!
  update: GradeUpdateWithoutRoutesInput!
}

input GradeWhereInput {
  AND: [GradeWhereInput!]
  NOT: [GradeWhereInput!]
  OR: [GradeWhereInput!]
  id: IntFilter
  name: StringFilter
  routes: RouteListRelationFilter
}

input GradeWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  avg: NestedFloatNullableFilter
  count: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  max: NestedIntNullableFilter
  min: NestedIntNullableFilter
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
  sum: NestedIntNullableFilter
}

input IntWithAggregatesFilter {
  avg: NestedFloatFilter
  count: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  max: NestedIntFilter
  min: NestedIntFilter
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
  sum: NestedIntFilter
}

type Location {
  clubs(cursor: ClubWhereUniqueInput, distinct: [ClubScalarFieldEnum!], orderBy: [ClubOrderByInput!], skip: Int, take: Int, where: ClubWhereInput): [Club!]!
  competitions(cursor: CompetitionWhereUniqueInput, distinct: [CompetitionScalarFieldEnum!], orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): [Competition!]!
  competitors(cursor: CompetitorWhereUniqueInput, distinct: [CompetitorScalarFieldEnum!], orderBy: [CompetitorOrderByInput!], skip: Int, take: Int, where: CompetitorWhereInput): [Competitor!]!
  country: Country!
  countryId: Int!
  id: Int!
  name: String
  region: Region!
  regionId: Int!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

type LocationAvgAggregate {
  countryId: Float!
  id: Float!
  regionId: Float!
}

type LocationCountAggregate {
  _all: Int!
  countryId: Int!
  id: Int!
  name: Int
  regionId: Int!
}

input LocationCreateInput {
  clubs: ClubCreateNestedManyWithoutLocationInput
  competitions: CompetitionCreateNestedManyWithoutLocationInput
  competitors: CompetitorCreateNestedManyWithoutLocationInput
  country: CountryCreateNestedOneWithoutLocationsInput!
  name: String
  region: RegionCreateNestedOneWithoutLocationsInput!
  users: UserCreateNestedManyWithoutLocationInput
}

input LocationCreateManyCountryInput {
  id: Int
  name: String
  regionId: Int!
}

input LocationCreateManyCountryInputEnvelope {
  data: [LocationCreateManyCountryInput!]!
  skipDuplicates: Boolean
}

input LocationCreateManyInput {
  countryId: Int!
  id: Int
  name: String
  regionId: Int!
}

input LocationCreateManyRegionInput {
  countryId: Int!
  id: Int
  name: String
}

input LocationCreateManyRegionInputEnvelope {
  data: [LocationCreateManyRegionInput!]!
  skipDuplicates: Boolean
}

input LocationCreateNestedManyWithoutCountryInput {
  connect: [LocationWhereUniqueInput!]
  connectOrCreate: [LocationCreateOrConnectWithoutCountryInput!]
  create: [LocationCreateWithoutCountryInput!]
  createMany: LocationCreateManyCountryInputEnvelope
}

input LocationCreateNestedManyWithoutRegionInput {
  connect: [LocationWhereUniqueInput!]
  connectOrCreate: [LocationCreateOrConnectWithoutRegionInput!]
  create: [LocationCreateWithoutRegionInput!]
  createMany: LocationCreateManyRegionInputEnvelope
}

input LocationCreateNestedOneWithoutClubsInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutClubsInput
  create: LocationCreateWithoutClubsInput
}

input LocationCreateNestedOneWithoutCompetitionsInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutCompetitionsInput
  create: LocationCreateWithoutCompetitionsInput
}

input LocationCreateNestedOneWithoutCompetitorsInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutCompetitorsInput
  create: LocationCreateWithoutCompetitorsInput
}

input LocationCreateNestedOneWithoutUsersInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutUsersInput
  create: LocationCreateWithoutUsersInput
}

input LocationCreateOrConnectWithoutClubsInput {
  create: LocationCreateWithoutClubsInput!
  where: LocationWhereUniqueInput!
}

input LocationCreateOrConnectWithoutCompetitionsInput {
  create: LocationCreateWithoutCompetitionsInput!
  where: LocationWhereUniqueInput!
}

input LocationCreateOrConnectWithoutCompetitorsInput {
  create: LocationCreateWithoutCompetitorsInput!
  where: LocationWhereUniqueInput!
}

input LocationCreateOrConnectWithoutCountryInput {
  create: LocationCreateWithoutCountryInput!
  where: LocationWhereUniqueInput!
}

input LocationCreateOrConnectWithoutRegionInput {
  create: LocationCreateWithoutRegionInput!
  where: LocationWhereUniqueInput!
}

input LocationCreateOrConnectWithoutUsersInput {
  create: LocationCreateWithoutUsersInput!
  where: LocationWhereUniqueInput!
}

input LocationCreateWithoutClubsInput {
  competitions: CompetitionCreateNestedManyWithoutLocationInput
  competitors: CompetitorCreateNestedManyWithoutLocationInput
  country: CountryCreateNestedOneWithoutLocationsInput!
  name: String
  region: RegionCreateNestedOneWithoutLocationsInput!
  users: UserCreateNestedManyWithoutLocationInput
}

input LocationCreateWithoutCompetitionsInput {
  clubs: ClubCreateNestedManyWithoutLocationInput
  competitors: CompetitorCreateNestedManyWithoutLocationInput
  country: CountryCreateNestedOneWithoutLocationsInput!
  name: String
  region: RegionCreateNestedOneWithoutLocationsInput!
  users: UserCreateNestedManyWithoutLocationInput
}

input LocationCreateWithoutCompetitorsInput {
  clubs: ClubCreateNestedManyWithoutLocationInput
  competitions: CompetitionCreateNestedManyWithoutLocationInput
  country: CountryCreateNestedOneWithoutLocationsInput!
  name: String
  region: RegionCreateNestedOneWithoutLocationsInput!
  users: UserCreateNestedManyWithoutLocationInput
}

input LocationCreateWithoutCountryInput {
  clubs: ClubCreateNestedManyWithoutLocationInput
  competitions: CompetitionCreateNestedManyWithoutLocationInput
  competitors: CompetitorCreateNestedManyWithoutLocationInput
  name: String
  region: RegionCreateNestedOneWithoutLocationsInput!
  users: UserCreateNestedManyWithoutLocationInput
}

input LocationCreateWithoutRegionInput {
  clubs: ClubCreateNestedManyWithoutLocationInput
  competitions: CompetitionCreateNestedManyWithoutLocationInput
  competitors: CompetitorCreateNestedManyWithoutLocationInput
  country: CountryCreateNestedOneWithoutLocationsInput!
  name: String
  users: UserCreateNestedManyWithoutLocationInput
}

input LocationCreateWithoutUsersInput {
  clubs: ClubCreateNestedManyWithoutLocationInput
  competitions: CompetitionCreateNestedManyWithoutLocationInput
  competitors: CompetitorCreateNestedManyWithoutLocationInput
  country: CountryCreateNestedOneWithoutLocationsInput!
  name: String
  region: RegionCreateNestedOneWithoutLocationsInput!
}

type LocationGroupBy {
  avg: LocationAvgAggregate
  count: LocationCountAggregate
  countryId: Int!
  id: Int!
  max: LocationMaxAggregate
  min: LocationMinAggregate
  name: String
  regionId: Int!
  sum: LocationSumAggregate
}

input LocationListRelationFilter {
  every: LocationWhereInput
  none: LocationWhereInput
  some: LocationWhereInput
}

type LocationMaxAggregate {
  countryId: Int!
  id: Int!
  name: String
  regionId: Int!
}

type LocationMinAggregate {
  countryId: Int!
  id: Int!
  name: String
  regionId: Int!
}

input LocationOrderByInput {
  countryId: SortOrder
  id: SortOrder
  name: SortOrder
  regionId: SortOrder
}

input LocationRelationFilter {
  is: LocationWhereInput
  isNot: LocationWhereInput
}

enum LocationScalarFieldEnum {
  countryId
  id
  name
  regionId
}

input LocationScalarWhereInput {
  AND: [LocationScalarWhereInput!]
  NOT: [LocationScalarWhereInput!]
  OR: [LocationScalarWhereInput!]
  countryId: IntFilter
  id: IntFilter
  name: StringNullableFilter
  regionId: IntFilter
}

input LocationScalarWhereWithAggregatesInput {
  AND: [LocationScalarWhereWithAggregatesInput!]
  NOT: [LocationScalarWhereWithAggregatesInput!]
  OR: [LocationScalarWhereWithAggregatesInput!]
  countryId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringNullableWithAggregatesFilter
  regionId: IntWithAggregatesFilter
}

type LocationSumAggregate {
  countryId: Int!
  id: Int!
  regionId: Int!
}

input LocationUpdateInput {
  clubs: ClubUpdateManyWithoutLocationInput
  competitions: CompetitionUpdateManyWithoutLocationInput
  competitors: CompetitorUpdateManyWithoutLocationInput
  country: CountryUpdateOneRequiredWithoutLocationsInput
  name: NullableStringFieldUpdateOperationsInput
  region: RegionUpdateOneRequiredWithoutLocationsInput
  users: UserUpdateManyWithoutLocationInput
}

input LocationUpdateManyMutationInput {
  name: NullableStringFieldUpdateOperationsInput
}

input LocationUpdateManyWithWhereWithoutCountryInput {
  data: LocationUpdateManyMutationInput!
  where: LocationScalarWhereInput!
}

input LocationUpdateManyWithWhereWithoutRegionInput {
  data: LocationUpdateManyMutationInput!
  where: LocationScalarWhereInput!
}

input LocationUpdateManyWithoutCountryInput {
  connect: [LocationWhereUniqueInput!]
  connectOrCreate: [LocationCreateOrConnectWithoutCountryInput!]
  create: [LocationCreateWithoutCountryInput!]
  createMany: LocationCreateManyCountryInputEnvelope
  delete: [LocationWhereUniqueInput!]
  deleteMany: [LocationScalarWhereInput!]
  disconnect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  update: [LocationUpdateWithWhereUniqueWithoutCountryInput!]
  updateMany: [LocationUpdateManyWithWhereWithoutCountryInput!]
  upsert: [LocationUpsertWithWhereUniqueWithoutCountryInput!]
}

input LocationUpdateManyWithoutRegionInput {
  connect: [LocationWhereUniqueInput!]
  connectOrCreate: [LocationCreateOrConnectWithoutRegionInput!]
  create: [LocationCreateWithoutRegionInput!]
  createMany: LocationCreateManyRegionInputEnvelope
  delete: [LocationWhereUniqueInput!]
  deleteMany: [LocationScalarWhereInput!]
  disconnect: [LocationWhereUniqueInput!]
  set: [LocationWhereUniqueInput!]
  update: [LocationUpdateWithWhereUniqueWithoutRegionInput!]
  updateMany: [LocationUpdateManyWithWhereWithoutRegionInput!]
  upsert: [LocationUpsertWithWhereUniqueWithoutRegionInput!]
}

input LocationUpdateOneRequiredWithoutClubsInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutClubsInput
  create: LocationCreateWithoutClubsInput
  update: LocationUpdateWithoutClubsInput
  upsert: LocationUpsertWithoutClubsInput
}

input LocationUpdateOneRequiredWithoutCompetitionsInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutCompetitionsInput
  create: LocationCreateWithoutCompetitionsInput
  update: LocationUpdateWithoutCompetitionsInput
  upsert: LocationUpsertWithoutCompetitionsInput
}

input LocationUpdateOneRequiredWithoutCompetitorsInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutCompetitorsInput
  create: LocationCreateWithoutCompetitorsInput
  update: LocationUpdateWithoutCompetitorsInput
  upsert: LocationUpsertWithoutCompetitorsInput
}

input LocationUpdateOneWithoutUsersInput {
  connect: LocationWhereUniqueInput
  connectOrCreate: LocationCreateOrConnectWithoutUsersInput
  create: LocationCreateWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  update: LocationUpdateWithoutUsersInput
  upsert: LocationUpsertWithoutUsersInput
}

input LocationUpdateWithWhereUniqueWithoutCountryInput {
  data: LocationUpdateWithoutCountryInput!
  where: LocationWhereUniqueInput!
}

input LocationUpdateWithWhereUniqueWithoutRegionInput {
  data: LocationUpdateWithoutRegionInput!
  where: LocationWhereUniqueInput!
}

input LocationUpdateWithoutClubsInput {
  competitions: CompetitionUpdateManyWithoutLocationInput
  competitors: CompetitorUpdateManyWithoutLocationInput
  country: CountryUpdateOneRequiredWithoutLocationsInput
  name: NullableStringFieldUpdateOperationsInput
  region: RegionUpdateOneRequiredWithoutLocationsInput
  users: UserUpdateManyWithoutLocationInput
}

input LocationUpdateWithoutCompetitionsInput {
  clubs: ClubUpdateManyWithoutLocationInput
  competitors: CompetitorUpdateManyWithoutLocationInput
  country: CountryUpdateOneRequiredWithoutLocationsInput
  name: NullableStringFieldUpdateOperationsInput
  region: RegionUpdateOneRequiredWithoutLocationsInput
  users: UserUpdateManyWithoutLocationInput
}

input LocationUpdateWithoutCompetitorsInput {
  clubs: ClubUpdateManyWithoutLocationInput
  competitions: CompetitionUpdateManyWithoutLocationInput
  country: CountryUpdateOneRequiredWithoutLocationsInput
  name: NullableStringFieldUpdateOperationsInput
  region: RegionUpdateOneRequiredWithoutLocationsInput
  users: UserUpdateManyWithoutLocationInput
}

input LocationUpdateWithoutCountryInput {
  clubs: ClubUpdateManyWithoutLocationInput
  competitions: CompetitionUpdateManyWithoutLocationInput
  competitors: CompetitorUpdateManyWithoutLocationInput
  name: NullableStringFieldUpdateOperationsInput
  region: RegionUpdateOneRequiredWithoutLocationsInput
  users: UserUpdateManyWithoutLocationInput
}

input LocationUpdateWithoutRegionInput {
  clubs: ClubUpdateManyWithoutLocationInput
  competitions: CompetitionUpdateManyWithoutLocationInput
  competitors: CompetitorUpdateManyWithoutLocationInput
  country: CountryUpdateOneRequiredWithoutLocationsInput
  name: NullableStringFieldUpdateOperationsInput
  users: UserUpdateManyWithoutLocationInput
}

input LocationUpdateWithoutUsersInput {
  clubs: ClubUpdateManyWithoutLocationInput
  competitions: CompetitionUpdateManyWithoutLocationInput
  competitors: CompetitorUpdateManyWithoutLocationInput
  country: CountryUpdateOneRequiredWithoutLocationsInput
  name: NullableStringFieldUpdateOperationsInput
  region: RegionUpdateOneRequiredWithoutLocationsInput
}

input LocationUpsertWithWhereUniqueWithoutCountryInput {
  create: LocationCreateWithoutCountryInput!
  update: LocationUpdateWithoutCountryInput!
  where: LocationWhereUniqueInput!
}

input LocationUpsertWithWhereUniqueWithoutRegionInput {
  create: LocationCreateWithoutRegionInput!
  update: LocationUpdateWithoutRegionInput!
  where: LocationWhereUniqueInput!
}

input LocationUpsertWithoutClubsInput {
  create: LocationCreateWithoutClubsInput!
  update: LocationUpdateWithoutClubsInput!
}

input LocationUpsertWithoutCompetitionsInput {
  create: LocationCreateWithoutCompetitionsInput!
  update: LocationUpdateWithoutCompetitionsInput!
}

input LocationUpsertWithoutCompetitorsInput {
  create: LocationCreateWithoutCompetitorsInput!
  update: LocationUpdateWithoutCompetitorsInput!
}

input LocationUpsertWithoutUsersInput {
  create: LocationCreateWithoutUsersInput!
  update: LocationUpdateWithoutUsersInput!
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  clubs: ClubListRelationFilter
  competitions: CompetitionListRelationFilter
  competitors: CompetitorListRelationFilter
  country: CountryRelationFilter
  countryId: IntFilter
  id: IntFilter
  name: StringNullableFilter
  region: RegionRelationFilter
  regionId: IntFilter
  users: UserListRelationFilter
}

input LocationWhereUniqueInput {
  id: Int
}

input LoginInput {
  email: String!
  password: String!
}

type LoginOutput {
  publicId: String!
  token: String!
}

type Mutation {
  createCategory(data: CategoryCreateInput!): Category!
  createClub(data: ClubCreateInput!): Club!
  createComment(data: CommentCreateInput!): Comment!
  createCompetition(data: CompetitionCreateInput!): Competition!
  createCompetitionType(data: CompetitionTypeCreateInput!): CompetitionType!
  createCompetitor(data: CompetitorCreateInput!): Competitor!
  createCountry(data: CountryCreateInput!): Country!
  createGrade(data: GradeCreateInput!): Grade!
  createLocation(data: LocationCreateInput!): Location!
  createManyCategory(data: [CategoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyClub(data: [ClubCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyComment(data: [CommentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCompetition(data: [CompetitionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCompetitionType(data: [CompetitionTypeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCompetitor(data: [CompetitorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCountry(data: [CountryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyGrade(data: [GradeCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyLocation(data: [LocationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRegion(data: [RegionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRegistration(data: [RegistrationCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyResult(data: [ResultCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRoute(data: [RouteCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyScoreBoulder(data: [ScoreBoulderCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyScoreLead(data: [ScoreLeadCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyScoreSpeed(data: [ScoreSpeedCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySeason(data: [SeasonCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyStartList(data: [StartListCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createRegion(data: RegionCreateInput!): Region!
  createRegistration(data: RegistrationCreateInput!): Registration!
  createResult(data: ResultCreateInput!): Result!
  createRoute(data: RouteCreateInput!): Route!
  createScoreBoulder(data: ScoreBoulderCreateInput!): ScoreBoulder!
  createScoreLead(data: ScoreLeadCreateInput!): ScoreLead!
  createScoreSpeed(data: ScoreSpeedCreateInput!): ScoreSpeed!
  createSeason(data: SeasonCreateInput!): Season!
  createStartList(data: StartListCreateInput!): StartList!
  createUser(data: UserCreateInput!): User!
  deleteCategory(where: CategoryWhereUniqueInput!): Category
  deleteClub(where: ClubWhereUniqueInput!): Club
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteCompetition(where: CompetitionWhereUniqueInput!): Competition
  deleteCompetitionType(where: CompetitionTypeWhereUniqueInput!): CompetitionType
  deleteCompetitor(where: CompetitorWhereUniqueInput!): Competitor
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteGrade(where: GradeWhereUniqueInput!): Grade
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteManyCategory(where: CategoryWhereInput): AffectedRowsOutput!
  deleteManyClub(where: ClubWhereInput): AffectedRowsOutput!
  deleteManyComment(where: CommentWhereInput): AffectedRowsOutput!
  deleteManyCompetition(where: CompetitionWhereInput): AffectedRowsOutput!
  deleteManyCompetitionType(where: CompetitionTypeWhereInput): AffectedRowsOutput!
  deleteManyCompetitor(where: CompetitorWhereInput): AffectedRowsOutput!
  deleteManyCountry(where: CountryWhereInput): AffectedRowsOutput!
  deleteManyGrade(where: GradeWhereInput): AffectedRowsOutput!
  deleteManyLocation(where: LocationWhereInput): AffectedRowsOutput!
  deleteManyRegion(where: RegionWhereInput): AffectedRowsOutput!
  deleteManyRegistration(where: RegistrationWhereInput): AffectedRowsOutput!
  deleteManyResult(where: ResultWhereInput): AffectedRowsOutput!
  deleteManyRoute(where: RouteWhereInput): AffectedRowsOutput!
  deleteManyScoreBoulder(where: ScoreBoulderWhereInput): AffectedRowsOutput!
  deleteManyScoreLead(where: ScoreLeadWhereInput): AffectedRowsOutput!
  deleteManyScoreSpeed(where: ScoreSpeedWhereInput): AffectedRowsOutput!
  deleteManySeason(where: SeasonWhereInput): AffectedRowsOutput!
  deleteManyStartList(where: StartListWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteRegion(where: RegionWhereUniqueInput!): Region
  deleteRegistration(where: RegistrationWhereUniqueInput!): Registration
  deleteResult(where: ResultWhereUniqueInput!): Result
  deleteRoute(where: RouteWhereUniqueInput!): Route
  deleteScoreBoulder(where: ScoreBoulderWhereUniqueInput!): ScoreBoulder
  deleteScoreLead(where: ScoreLeadWhereUniqueInput!): ScoreLead
  deleteScoreSpeed(where: ScoreSpeedWhereUniqueInput!): ScoreSpeed
  deleteSeason(where: SeasonWhereUniqueInput!): Season
  deleteStartList(where: StartListWhereUniqueInput!): StartList
  deleteUser(where: UserWhereUniqueInput!): User
  login(credentials: LoginInput!): LoginOutput!
  register(credentials: RegisterInput!): User!
  updateCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateClub(data: ClubUpdateInput!, where: ClubWhereUniqueInput!): Club
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateCompetition(data: CompetitionUpdateInput!, where: CompetitionWhereUniqueInput!): Competition
  updateCompetitionType(data: CompetitionTypeUpdateInput!, where: CompetitionTypeWhereUniqueInput!): CompetitionType
  updateCompetitor(data: CompetitorUpdateInput!, where: CompetitorWhereUniqueInput!): Competitor
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateGrade(data: GradeUpdateInput!, where: GradeWhereUniqueInput!): Grade
  updateLocation(data: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): AffectedRowsOutput!
  updateManyClub(data: ClubUpdateManyMutationInput!, where: ClubWhereInput): AffectedRowsOutput!
  updateManyComment(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): AffectedRowsOutput!
  updateManyCompetition(data: CompetitionUpdateManyMutationInput!, where: CompetitionWhereInput): AffectedRowsOutput!
  updateManyCompetitionType(data: CompetitionTypeUpdateManyMutationInput!, where: CompetitionTypeWhereInput): AffectedRowsOutput!
  updateManyCompetitor(data: CompetitorUpdateManyMutationInput!, where: CompetitorWhereInput): AffectedRowsOutput!
  updateManyCountry(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): AffectedRowsOutput!
  updateManyGrade(data: GradeUpdateManyMutationInput!, where: GradeWhereInput): AffectedRowsOutput!
  updateManyLocation(data: LocationUpdateManyMutationInput!, where: LocationWhereInput): AffectedRowsOutput!
  updateManyRegion(data: RegionUpdateManyMutationInput!, where: RegionWhereInput): AffectedRowsOutput!
  updateManyRegistration(data: RegistrationUpdateManyMutationInput!, where: RegistrationWhereInput): AffectedRowsOutput!
  updateManyResult(data: ResultUpdateManyMutationInput!, where: ResultWhereInput): AffectedRowsOutput!
  updateManyRoute(data: RouteUpdateManyMutationInput!, where: RouteWhereInput): AffectedRowsOutput!
  updateManyScoreBoulder(data: ScoreBoulderUpdateManyMutationInput!, where: ScoreBoulderWhereInput): AffectedRowsOutput!
  updateManyScoreLead(data: ScoreLeadUpdateManyMutationInput!, where: ScoreLeadWhereInput): AffectedRowsOutput!
  updateManyScoreSpeed(data: ScoreSpeedUpdateManyMutationInput!, where: ScoreSpeedWhereInput): AffectedRowsOutput!
  updateManySeason(data: SeasonUpdateManyMutationInput!, where: SeasonWhereInput): AffectedRowsOutput!
  updateManyStartList(data: StartListUpdateManyMutationInput!, where: StartListWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateRegion(data: RegionUpdateInput!, where: RegionWhereUniqueInput!): Region
  updateRegistration(data: RegistrationUpdateInput!, where: RegistrationWhereUniqueInput!): Registration
  updateResult(data: ResultUpdateInput!, where: ResultWhereUniqueInput!): Result
  updateRoute(data: RouteUpdateInput!, where: RouteWhereUniqueInput!): Route
  updateScoreBoulder(data: ScoreBoulderUpdateInput!, where: ScoreBoulderWhereUniqueInput!): ScoreBoulder
  updateScoreLead(data: ScoreLeadUpdateInput!, where: ScoreLeadWhereUniqueInput!): ScoreLead
  updateScoreSpeed(data: ScoreSpeedUpdateInput!, where: ScoreSpeedWhereUniqueInput!): ScoreSpeed
  updateSeason(data: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season
  updateStartList(data: StartListUpdateInput!, where: StartListWhereUniqueInput!): StartList
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertClub(create: ClubCreateInput!, update: ClubUpdateInput!, where: ClubWhereUniqueInput!): Club!
  upsertComment(create: CommentCreateInput!, update: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment!
  upsertCompetition(create: CompetitionCreateInput!, update: CompetitionUpdateInput!, where: CompetitionWhereUniqueInput!): Competition!
  upsertCompetitionType(create: CompetitionTypeCreateInput!, update: CompetitionTypeUpdateInput!, where: CompetitionTypeWhereUniqueInput!): CompetitionType!
  upsertCompetitor(create: CompetitorCreateInput!, update: CompetitorUpdateInput!, where: CompetitorWhereUniqueInput!): Competitor!
  upsertCountry(create: CountryCreateInput!, update: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country!
  upsertGrade(create: GradeCreateInput!, update: GradeUpdateInput!, where: GradeWhereUniqueInput!): Grade!
  upsertLocation(create: LocationCreateInput!, update: LocationUpdateInput!, where: LocationWhereUniqueInput!): Location!
  upsertRegion(create: RegionCreateInput!, update: RegionUpdateInput!, where: RegionWhereUniqueInput!): Region!
  upsertRegistration(create: RegistrationCreateInput!, update: RegistrationUpdateInput!, where: RegistrationWhereUniqueInput!): Registration!
  upsertResult(create: ResultCreateInput!, update: ResultUpdateInput!, where: ResultWhereUniqueInput!): Result!
  upsertRoute(create: RouteCreateInput!, update: RouteUpdateInput!, where: RouteWhereUniqueInput!): Route!
  upsertScoreBoulder(create: ScoreBoulderCreateInput!, update: ScoreBoulderUpdateInput!, where: ScoreBoulderWhereUniqueInput!): ScoreBoulder!
  upsertScoreLead(create: ScoreLeadCreateInput!, update: ScoreLeadUpdateInput!, where: ScoreLeadWhereUniqueInput!): ScoreLead!
  upsertScoreSpeed(create: ScoreSpeedCreateInput!, update: ScoreSpeedUpdateInput!, where: ScoreSpeedWhereUniqueInput!): ScoreSpeed!
  upsertSeason(create: SeasonCreateInput!, update: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season!
  upsertStartList(create: StartListCreateInput!, update: StartListUpdateInput!, where: StartListWhereUniqueInput!): StartList!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  count: NestedIntFilter
  equals: Boolean
  max: NestedBoolFilter
  min: NestedBoolFilter
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  count: NestedIntFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  max: NestedDateTimeFilter
  min: NestedDateTimeFilter
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedEnumGenderFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderFilter
  notIn: [Gender!]
}

input NestedEnumGenderWithAggregatesFilter {
  count: NestedIntFilter
  equals: Gender
  in: [Gender!]
  max: NestedEnumGenderFilter
  min: NestedEnumGenderFilter
  not: NestedEnumGenderWithAggregatesFilter
  notIn: [Gender!]
}

input NestedEnumRouteTypeFilter {
  equals: RouteType
  in: [RouteType!]
  not: NestedEnumRouteTypeFilter
  notIn: [RouteType!]
}

input NestedEnumRouteTypeWithAggregatesFilter {
  count: NestedIntFilter
  equals: RouteType
  in: [RouteType!]
  max: NestedEnumRouteTypeFilter
  min: NestedEnumRouteTypeFilter
  not: NestedEnumRouteTypeWithAggregatesFilter
  notIn: [RouteType!]
}

input NestedEnumUserRoleFilter {
  equals: UserRole
  in: [UserRole!]
  not: NestedEnumUserRoleFilter
  notIn: [UserRole!]
}

input NestedEnumUserRoleWithAggregatesFilter {
  count: NestedIntFilter
  equals: UserRole
  in: [UserRole!]
  max: NestedEnumUserRoleFilter
  min: NestedEnumUserRoleFilter
  not: NestedEnumUserRoleWithAggregatesFilter
  notIn: [UserRole!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  avg: NestedFloatNullableFilter
  count: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  max: NestedIntNullableFilter
  min: NestedIntNullableFilter
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
  sum: NestedIntNullableFilter
}

input NestedIntWithAggregatesFilter {
  avg: NestedFloatFilter
  count: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  max: NestedIntFilter
  min: NestedIntFilter
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
  sum: NestedIntFilter
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  contains: String
  count: NestedIntNullableFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  max: NestedStringNullableFilter
  min: NestedStringNullableFilter
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  contains: String
  count: NestedIntFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  max: NestedStringFilter
  min: NestedStringFilter
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateClub(cursor: ClubWhereUniqueInput, orderBy: [ClubOrderByInput!], skip: Int, take: Int, where: ClubWhereInput): AggregateClub!
  aggregateComment(cursor: CommentWhereUniqueInput, orderBy: [CommentOrderByInput!], skip: Int, take: Int, where: CommentWhereInput): AggregateComment!
  aggregateCompetition(cursor: CompetitionWhereUniqueInput, orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): AggregateCompetition!
  aggregateCompetitionType(cursor: CompetitionTypeWhereUniqueInput, orderBy: [CompetitionTypeOrderByInput!], skip: Int, take: Int, where: CompetitionTypeWhereInput): AggregateCompetitionType!
  aggregateCompetitor(cursor: CompetitorWhereUniqueInput, orderBy: [CompetitorOrderByInput!], skip: Int, take: Int, where: CompetitorWhereInput): AggregateCompetitor!
  aggregateCountry(cursor: CountryWhereUniqueInput, orderBy: [CountryOrderByInput!], skip: Int, take: Int, where: CountryWhereInput): AggregateCountry!
  aggregateGrade(cursor: GradeWhereUniqueInput, orderBy: [GradeOrderByInput!], skip: Int, take: Int, where: GradeWhereInput): AggregateGrade!
  aggregateLocation(cursor: LocationWhereUniqueInput, orderBy: [LocationOrderByInput!], skip: Int, take: Int, where: LocationWhereInput): AggregateLocation!
  aggregateRegion(cursor: RegionWhereUniqueInput, orderBy: [RegionOrderByInput!], skip: Int, take: Int, where: RegionWhereInput): AggregateRegion!
  aggregateRegistration(cursor: RegistrationWhereUniqueInput, orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): AggregateRegistration!
  aggregateResult(cursor: ResultWhereUniqueInput, orderBy: [ResultOrderByInput!], skip: Int, take: Int, where: ResultWhereInput): AggregateResult!
  aggregateRoute(cursor: RouteWhereUniqueInput, orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): AggregateRoute!
  aggregateScoreBoulder(cursor: ScoreBoulderWhereUniqueInput, orderBy: [ScoreBoulderOrderByInput!], skip: Int, take: Int, where: ScoreBoulderWhereInput): AggregateScoreBoulder!
  aggregateScoreLead(cursor: ScoreLeadWhereUniqueInput, orderBy: [ScoreLeadOrderByInput!], skip: Int, take: Int, where: ScoreLeadWhereInput): AggregateScoreLead!
  aggregateScoreSpeed(cursor: ScoreSpeedWhereUniqueInput, orderBy: [ScoreSpeedOrderByInput!], skip: Int, take: Int, where: ScoreSpeedWhereInput): AggregateScoreSpeed!
  aggregateSeason(cursor: SeasonWhereUniqueInput, orderBy: [SeasonOrderByInput!], skip: Int, take: Int, where: SeasonWhereInput): AggregateSeason!
  aggregateStartList(cursor: StartListWhereUniqueInput, orderBy: [StartListOrderByInput!], skip: Int, take: Int, where: StartListWhereInput): AggregateStartList!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  club(where: ClubWhereUniqueInput!): Club
  clubs(cursor: ClubWhereUniqueInput, distinct: [ClubScalarFieldEnum!], orderBy: [ClubOrderByInput!], skip: Int, take: Int, where: ClubWhereInput): [Club!]!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  competition(where: CompetitionWhereUniqueInput!): Competition
  competitionType(where: CompetitionTypeWhereUniqueInput!): CompetitionType
  competitionTypes(cursor: CompetitionTypeWhereUniqueInput, distinct: [CompetitionTypeScalarFieldEnum!], orderBy: [CompetitionTypeOrderByInput!], skip: Int, take: Int, where: CompetitionTypeWhereInput): [CompetitionType!]!
  competitions(cursor: CompetitionWhereUniqueInput, distinct: [CompetitionScalarFieldEnum!], orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): [Competition!]!
  competitor(where: CompetitorWhereUniqueInput!): Competitor
  competitors(cursor: CompetitorWhereUniqueInput, distinct: [CompetitorScalarFieldEnum!], orderBy: [CompetitorOrderByInput!], skip: Int, take: Int, where: CompetitorWhereInput): [Competitor!]!
  countries(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByInput!], skip: Int, take: Int, where: CountryWhereInput): [Country!]!
  country(where: CountryWhereUniqueInput!): Country
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstClub(cursor: ClubWhereUniqueInput, distinct: [ClubScalarFieldEnum!], orderBy: [ClubOrderByInput!], skip: Int, take: Int, where: ClubWhereInput): Club
  findFirstComment(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByInput!], skip: Int, take: Int, where: CommentWhereInput): Comment
  findFirstCompetition(cursor: CompetitionWhereUniqueInput, distinct: [CompetitionScalarFieldEnum!], orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): Competition
  findFirstCompetitionType(cursor: CompetitionTypeWhereUniqueInput, distinct: [CompetitionTypeScalarFieldEnum!], orderBy: [CompetitionTypeOrderByInput!], skip: Int, take: Int, where: CompetitionTypeWhereInput): CompetitionType
  findFirstCompetitor(cursor: CompetitorWhereUniqueInput, distinct: [CompetitorScalarFieldEnum!], orderBy: [CompetitorOrderByInput!], skip: Int, take: Int, where: CompetitorWhereInput): Competitor
  findFirstCountry(cursor: CountryWhereUniqueInput, distinct: [CountryScalarFieldEnum!], orderBy: [CountryOrderByInput!], skip: Int, take: Int, where: CountryWhereInput): Country
  findFirstGrade(cursor: GradeWhereUniqueInput, distinct: [GradeScalarFieldEnum!], orderBy: [GradeOrderByInput!], skip: Int, take: Int, where: GradeWhereInput): Grade
  findFirstLocation(cursor: LocationWhereUniqueInput, distinct: [LocationScalarFieldEnum!], orderBy: [LocationOrderByInput!], skip: Int, take: Int, where: LocationWhereInput): Location
  findFirstRegion(cursor: RegionWhereUniqueInput, distinct: [RegionScalarFieldEnum!], orderBy: [RegionOrderByInput!], skip: Int, take: Int, where: RegionWhereInput): Region
  findFirstRegistration(cursor: RegistrationWhereUniqueInput, distinct: [RegistrationScalarFieldEnum!], orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): Registration
  findFirstResult(cursor: ResultWhereUniqueInput, distinct: [ResultScalarFieldEnum!], orderBy: [ResultOrderByInput!], skip: Int, take: Int, where: ResultWhereInput): Result
  findFirstRoute(cursor: RouteWhereUniqueInput, distinct: [RouteScalarFieldEnum!], orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): Route
  findFirstScoreBoulder(cursor: ScoreBoulderWhereUniqueInput, distinct: [ScoreBoulderScalarFieldEnum!], orderBy: [ScoreBoulderOrderByInput!], skip: Int, take: Int, where: ScoreBoulderWhereInput): ScoreBoulder
  findFirstScoreLead(cursor: ScoreLeadWhereUniqueInput, distinct: [ScoreLeadScalarFieldEnum!], orderBy: [ScoreLeadOrderByInput!], skip: Int, take: Int, where: ScoreLeadWhereInput): ScoreLead
  findFirstScoreSpeed(cursor: ScoreSpeedWhereUniqueInput, distinct: [ScoreSpeedScalarFieldEnum!], orderBy: [ScoreSpeedOrderByInput!], skip: Int, take: Int, where: ScoreSpeedWhereInput): ScoreSpeed
  findFirstSeason(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByInput!], skip: Int, take: Int, where: SeasonWhereInput): Season
  findFirstStartList(cursor: StartListWhereUniqueInput, distinct: [StartListScalarFieldEnum!], orderBy: [StartListOrderByInput!], skip: Int, take: Int, where: StartListWhereInput): StartList
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): User
  getCompetitorForScoring(data: FindStartListInput!): Competitor!
  grade(where: GradeWhereUniqueInput!): Grade
  grades(cursor: GradeWhereUniqueInput, distinct: [GradeScalarFieldEnum!], orderBy: [GradeOrderByInput!], skip: Int, take: Int, where: GradeWhereInput): [Grade!]!
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByClub(by: [ClubScalarFieldEnum!]!, having: ClubScalarWhereWithAggregatesInput, orderBy: [ClubOrderByInput!], skip: Int, take: Int, where: ClubWhereInput): [ClubGroupBy!]!
  groupByComment(by: [CommentScalarFieldEnum!]!, having: CommentScalarWhereWithAggregatesInput, orderBy: [CommentOrderByInput!], skip: Int, take: Int, where: CommentWhereInput): [CommentGroupBy!]!
  groupByCompetition(by: [CompetitionScalarFieldEnum!]!, having: CompetitionScalarWhereWithAggregatesInput, orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): [CompetitionGroupBy!]!
  groupByCompetitionType(by: [CompetitionTypeScalarFieldEnum!]!, having: CompetitionTypeScalarWhereWithAggregatesInput, orderBy: [CompetitionTypeOrderByInput!], skip: Int, take: Int, where: CompetitionTypeWhereInput): [CompetitionTypeGroupBy!]!
  groupByCompetitor(by: [CompetitorScalarFieldEnum!]!, having: CompetitorScalarWhereWithAggregatesInput, orderBy: [CompetitorOrderByInput!], skip: Int, take: Int, where: CompetitorWhereInput): [CompetitorGroupBy!]!
  groupByCountry(by: [CountryScalarFieldEnum!]!, having: CountryScalarWhereWithAggregatesInput, orderBy: [CountryOrderByInput!], skip: Int, take: Int, where: CountryWhereInput): [CountryGroupBy!]!
  groupByGrade(by: [GradeScalarFieldEnum!]!, having: GradeScalarWhereWithAggregatesInput, orderBy: [GradeOrderByInput!], skip: Int, take: Int, where: GradeWhereInput): [GradeGroupBy!]!
  groupByLocation(by: [LocationScalarFieldEnum!]!, having: LocationScalarWhereWithAggregatesInput, orderBy: [LocationOrderByInput!], skip: Int, take: Int, where: LocationWhereInput): [LocationGroupBy!]!
  groupByRegion(by: [RegionScalarFieldEnum!]!, having: RegionScalarWhereWithAggregatesInput, orderBy: [RegionOrderByInput!], skip: Int, take: Int, where: RegionWhereInput): [RegionGroupBy!]!
  groupByRegistration(by: [RegistrationScalarFieldEnum!]!, having: RegistrationScalarWhereWithAggregatesInput, orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): [RegistrationGroupBy!]!
  groupByResult(by: [ResultScalarFieldEnum!]!, having: ResultScalarWhereWithAggregatesInput, orderBy: [ResultOrderByInput!], skip: Int, take: Int, where: ResultWhereInput): [ResultGroupBy!]!
  groupByRoute(by: [RouteScalarFieldEnum!]!, having: RouteScalarWhereWithAggregatesInput, orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): [RouteGroupBy!]!
  groupByScoreBoulder(by: [ScoreBoulderScalarFieldEnum!]!, having: ScoreBoulderScalarWhereWithAggregatesInput, orderBy: [ScoreBoulderOrderByInput!], skip: Int, take: Int, where: ScoreBoulderWhereInput): [ScoreBoulderGroupBy!]!
  groupByScoreLead(by: [ScoreLeadScalarFieldEnum!]!, having: ScoreLeadScalarWhereWithAggregatesInput, orderBy: [ScoreLeadOrderByInput!], skip: Int, take: Int, where: ScoreLeadWhereInput): [ScoreLeadGroupBy!]!
  groupByScoreSpeed(by: [ScoreSpeedScalarFieldEnum!]!, having: ScoreSpeedScalarWhereWithAggregatesInput, orderBy: [ScoreSpeedOrderByInput!], skip: Int, take: Int, where: ScoreSpeedWhereInput): [ScoreSpeedGroupBy!]!
  groupBySeason(by: [SeasonScalarFieldEnum!]!, having: SeasonScalarWhereWithAggregatesInput, orderBy: [SeasonOrderByInput!], skip: Int, take: Int, where: SeasonWhereInput): [SeasonGroupBy!]!
  groupByStartList(by: [StartListScalarFieldEnum!]!, having: StartListScalarWhereWithAggregatesInput, orderBy: [StartListOrderByInput!], skip: Int, take: Int, where: StartListWhereInput): [StartListGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  location(where: LocationWhereUniqueInput!): Location
  locations(cursor: LocationWhereUniqueInput, distinct: [LocationScalarFieldEnum!], orderBy: [LocationOrderByInput!], skip: Int, take: Int, where: LocationWhereInput): [Location!]!
  region(where: RegionWhereUniqueInput!): Region
  regions(cursor: RegionWhereUniqueInput, distinct: [RegionScalarFieldEnum!], orderBy: [RegionOrderByInput!], skip: Int, take: Int, where: RegionWhereInput): [Region!]!
  registration(where: RegistrationWhereUniqueInput!): Registration
  registrations(cursor: RegistrationWhereUniqueInput, distinct: [RegistrationScalarFieldEnum!], orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): [Registration!]!
  result(where: ResultWhereUniqueInput!): Result
  results(cursor: ResultWhereUniqueInput, distinct: [ResultScalarFieldEnum!], orderBy: [ResultOrderByInput!], skip: Int, take: Int, where: ResultWhereInput): [Result!]!
  route(where: RouteWhereUniqueInput!): Route
  routes(cursor: RouteWhereUniqueInput, distinct: [RouteScalarFieldEnum!], orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): [Route!]!
  scoreBoulder(where: ScoreBoulderWhereUniqueInput!): ScoreBoulder
  scoreBoulders(cursor: ScoreBoulderWhereUniqueInput, distinct: [ScoreBoulderScalarFieldEnum!], orderBy: [ScoreBoulderOrderByInput!], skip: Int, take: Int, where: ScoreBoulderWhereInput): [ScoreBoulder!]!
  scoreLead(where: ScoreLeadWhereUniqueInput!): ScoreLead
  scoreLeads(cursor: ScoreLeadWhereUniqueInput, distinct: [ScoreLeadScalarFieldEnum!], orderBy: [ScoreLeadOrderByInput!], skip: Int, take: Int, where: ScoreLeadWhereInput): [ScoreLead!]!
  scoreSpeed(where: ScoreSpeedWhereUniqueInput!): ScoreSpeed
  scoreSpeeds(cursor: ScoreSpeedWhereUniqueInput, distinct: [ScoreSpeedScalarFieldEnum!], orderBy: [ScoreSpeedOrderByInput!], skip: Int, take: Int, where: ScoreSpeedWhereInput): [ScoreSpeed!]!
  season(where: SeasonWhereUniqueInput!): Season
  seasons(cursor: SeasonWhereUniqueInput, distinct: [SeasonScalarFieldEnum!], orderBy: [SeasonOrderByInput!], skip: Int, take: Int, where: SeasonWhereInput): [Season!]!
  startList(where: StartListWhereUniqueInput!): StartList
  startLists(cursor: StartListWhereUniqueInput, distinct: [StartListScalarFieldEnum!], orderBy: [StartListOrderByInput!], skip: Int, take: Int, where: StartListWhereInput): [StartList!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Region {
  id: Int!
  locations(cursor: LocationWhereUniqueInput, distinct: [LocationScalarFieldEnum!], orderBy: [LocationOrderByInput!], skip: Int, take: Int, where: LocationWhereInput): [Location!]!
  name: String!
}

type RegionAvgAggregate {
  id: Float!
}

type RegionCountAggregate {
  _all: Int!
  id: Int!
  name: Int
}

input RegionCreateInput {
  locations: LocationCreateNestedManyWithoutRegionInput
  name: String!
}

input RegionCreateManyInput {
  id: Int
  name: String!
}

input RegionCreateNestedOneWithoutLocationsInput {
  connect: RegionWhereUniqueInput
  connectOrCreate: RegionCreateOrConnectWithoutLocationsInput
  create: RegionCreateWithoutLocationsInput
}

input RegionCreateOrConnectWithoutLocationsInput {
  create: RegionCreateWithoutLocationsInput!
  where: RegionWhereUniqueInput!
}

input RegionCreateWithoutLocationsInput {
  name: String!
}

type RegionGroupBy {
  avg: RegionAvgAggregate
  count: RegionCountAggregate
  id: Int!
  max: RegionMaxAggregate
  min: RegionMinAggregate
  name: String!
  sum: RegionSumAggregate
}

type RegionMaxAggregate {
  id: Int!
  name: String
}

type RegionMinAggregate {
  id: Int!
  name: String
}

input RegionOrderByInput {
  id: SortOrder
  name: SortOrder
}

input RegionRelationFilter {
  is: RegionWhereInput
  isNot: RegionWhereInput
}

enum RegionScalarFieldEnum {
  id
  name
}

input RegionScalarWhereWithAggregatesInput {
  AND: [RegionScalarWhereWithAggregatesInput!]
  NOT: [RegionScalarWhereWithAggregatesInput!]
  OR: [RegionScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type RegionSumAggregate {
  id: Int!
}

input RegionUpdateInput {
  locations: LocationUpdateManyWithoutRegionInput
  name: StringFieldUpdateOperationsInput
}

input RegionUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input RegionUpdateOneRequiredWithoutLocationsInput {
  connect: RegionWhereUniqueInput
  connectOrCreate: RegionCreateOrConnectWithoutLocationsInput
  create: RegionCreateWithoutLocationsInput
  update: RegionUpdateWithoutLocationsInput
  upsert: RegionUpsertWithoutLocationsInput
}

input RegionUpdateWithoutLocationsInput {
  name: StringFieldUpdateOperationsInput
}

input RegionUpsertWithoutLocationsInput {
  create: RegionCreateWithoutLocationsInput!
  update: RegionUpdateWithoutLocationsInput!
}

input RegionWhereInput {
  AND: [RegionWhereInput!]
  NOT: [RegionWhereInput!]
  OR: [RegionWhereInput!]
  id: IntFilter
  locations: LocationListRelationFilter
  name: StringFilter
}

input RegionWhereUniqueInput {
  id: Int
}

input RegisterInput {
  email: String!
  firstName: String!
  lastName: String!
  locationId: Float
  password: String!
}

type Registration {
  accepted: Boolean!
  acceptor: User!
  acceptorId: Int!
  competition: Competition!
  competitionId: Int!
  competitor: Competitor!
  competitorId: Int!
  createdAt: DateTime!
  id: Int!
  paid: Boolean!
  registrant: User!
  registrantId: Int!
  updatedAt: DateTime!
}

type RegistrationAvgAggregate {
  acceptorId: Float!
  competitionId: Float!
  competitorId: Float!
  id: Float!
  registrantId: Float!
}

type RegistrationCountAggregate {
  _all: Int!
  accepted: Int
  acceptorId: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: Int
  id: Int!
  paid: Int
  registrantId: Int!
  updatedAt: Int
}

input RegistrationCreateInput {
  accepted: Boolean
  acceptor: UserCreateNestedOneWithoutAcceptancesInput!
  competition: CompetitionCreateNestedOneWithoutRegistrationsInput!
  competitor: CompetitorCreateNestedOneWithoutRegistrationsInput!
  createdAt: DateTime
  paid: Boolean
  registrant: UserCreateNestedOneWithoutRegistrationsInput!
  updatedAt: DateTime
}

input RegistrationCreateManyAcceptorInput {
  accepted: Boolean
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  paid: Boolean
  registrantId: Int!
  updatedAt: DateTime
}

input RegistrationCreateManyAcceptorInputEnvelope {
  data: [RegistrationCreateManyAcceptorInput!]!
  skipDuplicates: Boolean
}

input RegistrationCreateManyCompetitionInput {
  accepted: Boolean
  acceptorId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  paid: Boolean
  registrantId: Int!
  updatedAt: DateTime
}

input RegistrationCreateManyCompetitionInputEnvelope {
  data: [RegistrationCreateManyCompetitionInput!]!
  skipDuplicates: Boolean
}

input RegistrationCreateManyCompetitorInput {
  accepted: Boolean
  acceptorId: Int!
  competitionId: Int!
  createdAt: DateTime
  id: Int
  paid: Boolean
  registrantId: Int!
  updatedAt: DateTime
}

input RegistrationCreateManyCompetitorInputEnvelope {
  data: [RegistrationCreateManyCompetitorInput!]!
  skipDuplicates: Boolean
}

input RegistrationCreateManyInput {
  accepted: Boolean
  acceptorId: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  paid: Boolean
  registrantId: Int!
  updatedAt: DateTime
}

input RegistrationCreateManyRegistrantInput {
  accepted: Boolean
  acceptorId: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  paid: Boolean
  updatedAt: DateTime
}

input RegistrationCreateManyRegistrantInputEnvelope {
  data: [RegistrationCreateManyRegistrantInput!]!
  skipDuplicates: Boolean
}

input RegistrationCreateNestedManyWithoutAcceptorInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutAcceptorInput!]
  create: [RegistrationCreateWithoutAcceptorInput!]
  createMany: RegistrationCreateManyAcceptorInputEnvelope
}

input RegistrationCreateNestedManyWithoutCompetitionInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutCompetitionInput!]
  create: [RegistrationCreateWithoutCompetitionInput!]
  createMany: RegistrationCreateManyCompetitionInputEnvelope
}

input RegistrationCreateNestedManyWithoutCompetitorInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutCompetitorInput!]
  create: [RegistrationCreateWithoutCompetitorInput!]
  createMany: RegistrationCreateManyCompetitorInputEnvelope
}

input RegistrationCreateNestedManyWithoutRegistrantInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutRegistrantInput!]
  create: [RegistrationCreateWithoutRegistrantInput!]
  createMany: RegistrationCreateManyRegistrantInputEnvelope
}

input RegistrationCreateOrConnectWithoutAcceptorInput {
  create: RegistrationCreateWithoutAcceptorInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationCreateOrConnectWithoutCompetitionInput {
  create: RegistrationCreateWithoutCompetitionInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationCreateOrConnectWithoutCompetitorInput {
  create: RegistrationCreateWithoutCompetitorInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationCreateOrConnectWithoutRegistrantInput {
  create: RegistrationCreateWithoutRegistrantInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationCreateWithoutAcceptorInput {
  accepted: Boolean
  competition: CompetitionCreateNestedOneWithoutRegistrationsInput!
  competitor: CompetitorCreateNestedOneWithoutRegistrationsInput!
  createdAt: DateTime
  paid: Boolean
  registrant: UserCreateNestedOneWithoutRegistrationsInput!
  updatedAt: DateTime
}

input RegistrationCreateWithoutCompetitionInput {
  accepted: Boolean
  acceptor: UserCreateNestedOneWithoutAcceptancesInput!
  competitor: CompetitorCreateNestedOneWithoutRegistrationsInput!
  createdAt: DateTime
  paid: Boolean
  registrant: UserCreateNestedOneWithoutRegistrationsInput!
  updatedAt: DateTime
}

input RegistrationCreateWithoutCompetitorInput {
  accepted: Boolean
  acceptor: UserCreateNestedOneWithoutAcceptancesInput!
  competition: CompetitionCreateNestedOneWithoutRegistrationsInput!
  createdAt: DateTime
  paid: Boolean
  registrant: UserCreateNestedOneWithoutRegistrationsInput!
  updatedAt: DateTime
}

input RegistrationCreateWithoutRegistrantInput {
  accepted: Boolean
  acceptor: UserCreateNestedOneWithoutAcceptancesInput!
  competition: CompetitionCreateNestedOneWithoutRegistrationsInput!
  competitor: CompetitorCreateNestedOneWithoutRegistrationsInput!
  createdAt: DateTime
  paid: Boolean
  updatedAt: DateTime
}

type RegistrationGroupBy {
  accepted: Boolean!
  acceptorId: Int!
  avg: RegistrationAvgAggregate
  competitionId: Int!
  competitorId: Int!
  count: RegistrationCountAggregate
  createdAt: DateTime!
  id: Int!
  max: RegistrationMaxAggregate
  min: RegistrationMinAggregate
  paid: Boolean!
  registrantId: Int!
  sum: RegistrationSumAggregate
  updatedAt: DateTime!
}

input RegistrationListRelationFilter {
  every: RegistrationWhereInput
  none: RegistrationWhereInput
  some: RegistrationWhereInput
}

type RegistrationMaxAggregate {
  accepted: Boolean
  acceptorId: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  paid: Boolean
  registrantId: Int!
  updatedAt: DateTime
}

type RegistrationMinAggregate {
  accepted: Boolean
  acceptorId: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  paid: Boolean
  registrantId: Int!
  updatedAt: DateTime
}

input RegistrationOrderByInput {
  accepted: SortOrder
  acceptorId: SortOrder
  competitionId: SortOrder
  competitorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  paid: SortOrder
  registrantId: SortOrder
  updatedAt: SortOrder
}

enum RegistrationScalarFieldEnum {
  accepted
  acceptorId
  competitionId
  competitorId
  createdAt
  id
  paid
  registrantId
  updatedAt
}

input RegistrationScalarWhereInput {
  AND: [RegistrationScalarWhereInput!]
  NOT: [RegistrationScalarWhereInput!]
  OR: [RegistrationScalarWhereInput!]
  accepted: BoolFilter
  acceptorId: IntFilter
  competitionId: IntFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  paid: BoolFilter
  registrantId: IntFilter
  updatedAt: DateTimeFilter
}

input RegistrationScalarWhereWithAggregatesInput {
  AND: [RegistrationScalarWhereWithAggregatesInput!]
  NOT: [RegistrationScalarWhereWithAggregatesInput!]
  OR: [RegistrationScalarWhereWithAggregatesInput!]
  accepted: BoolWithAggregatesFilter
  acceptorId: IntWithAggregatesFilter
  competitionId: IntWithAggregatesFilter
  competitorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  paid: BoolWithAggregatesFilter
  registrantId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type RegistrationSumAggregate {
  acceptorId: Int!
  competitionId: Int!
  competitorId: Int!
  id: Int!
  registrantId: Int!
}

input RegistrationUpdateInput {
  accepted: BoolFieldUpdateOperationsInput
  acceptor: UserUpdateOneRequiredWithoutAcceptancesInput
  competition: CompetitionUpdateOneRequiredWithoutRegistrationsInput
  competitor: CompetitorUpdateOneRequiredWithoutRegistrationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  paid: BoolFieldUpdateOperationsInput
  registrant: UserUpdateOneRequiredWithoutRegistrationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RegistrationUpdateManyMutationInput {
  accepted: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  paid: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RegistrationUpdateManyWithWhereWithoutAcceptorInput {
  data: RegistrationUpdateManyMutationInput!
  where: RegistrationScalarWhereInput!
}

input RegistrationUpdateManyWithWhereWithoutCompetitionInput {
  data: RegistrationUpdateManyMutationInput!
  where: RegistrationScalarWhereInput!
}

input RegistrationUpdateManyWithWhereWithoutCompetitorInput {
  data: RegistrationUpdateManyMutationInput!
  where: RegistrationScalarWhereInput!
}

input RegistrationUpdateManyWithWhereWithoutRegistrantInput {
  data: RegistrationUpdateManyMutationInput!
  where: RegistrationScalarWhereInput!
}

input RegistrationUpdateManyWithoutAcceptorInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutAcceptorInput!]
  create: [RegistrationCreateWithoutAcceptorInput!]
  createMany: RegistrationCreateManyAcceptorInputEnvelope
  delete: [RegistrationWhereUniqueInput!]
  deleteMany: [RegistrationScalarWhereInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutAcceptorInput!]
  updateMany: [RegistrationUpdateManyWithWhereWithoutAcceptorInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutAcceptorInput!]
}

input RegistrationUpdateManyWithoutCompetitionInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutCompetitionInput!]
  create: [RegistrationCreateWithoutCompetitionInput!]
  createMany: RegistrationCreateManyCompetitionInputEnvelope
  delete: [RegistrationWhereUniqueInput!]
  deleteMany: [RegistrationScalarWhereInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutCompetitionInput!]
  updateMany: [RegistrationUpdateManyWithWhereWithoutCompetitionInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutCompetitionInput!]
}

input RegistrationUpdateManyWithoutCompetitorInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutCompetitorInput!]
  create: [RegistrationCreateWithoutCompetitorInput!]
  createMany: RegistrationCreateManyCompetitorInputEnvelope
  delete: [RegistrationWhereUniqueInput!]
  deleteMany: [RegistrationScalarWhereInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutCompetitorInput!]
  updateMany: [RegistrationUpdateManyWithWhereWithoutCompetitorInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutCompetitorInput!]
}

input RegistrationUpdateManyWithoutRegistrantInput {
  connect: [RegistrationWhereUniqueInput!]
  connectOrCreate: [RegistrationCreateOrConnectWithoutRegistrantInput!]
  create: [RegistrationCreateWithoutRegistrantInput!]
  createMany: RegistrationCreateManyRegistrantInputEnvelope
  delete: [RegistrationWhereUniqueInput!]
  deleteMany: [RegistrationScalarWhereInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  set: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutRegistrantInput!]
  updateMany: [RegistrationUpdateManyWithWhereWithoutRegistrantInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutRegistrantInput!]
}

input RegistrationUpdateWithWhereUniqueWithoutAcceptorInput {
  data: RegistrationUpdateWithoutAcceptorInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationUpdateWithWhereUniqueWithoutCompetitionInput {
  data: RegistrationUpdateWithoutCompetitionInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationUpdateWithWhereUniqueWithoutCompetitorInput {
  data: RegistrationUpdateWithoutCompetitorInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationUpdateWithWhereUniqueWithoutRegistrantInput {
  data: RegistrationUpdateWithoutRegistrantInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationUpdateWithoutAcceptorInput {
  accepted: BoolFieldUpdateOperationsInput
  competition: CompetitionUpdateOneRequiredWithoutRegistrationsInput
  competitor: CompetitorUpdateOneRequiredWithoutRegistrationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  paid: BoolFieldUpdateOperationsInput
  registrant: UserUpdateOneRequiredWithoutRegistrationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RegistrationUpdateWithoutCompetitionInput {
  accepted: BoolFieldUpdateOperationsInput
  acceptor: UserUpdateOneRequiredWithoutAcceptancesInput
  competitor: CompetitorUpdateOneRequiredWithoutRegistrationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  paid: BoolFieldUpdateOperationsInput
  registrant: UserUpdateOneRequiredWithoutRegistrationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RegistrationUpdateWithoutCompetitorInput {
  accepted: BoolFieldUpdateOperationsInput
  acceptor: UserUpdateOneRequiredWithoutAcceptancesInput
  competition: CompetitionUpdateOneRequiredWithoutRegistrationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  paid: BoolFieldUpdateOperationsInput
  registrant: UserUpdateOneRequiredWithoutRegistrationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RegistrationUpdateWithoutRegistrantInput {
  accepted: BoolFieldUpdateOperationsInput
  acceptor: UserUpdateOneRequiredWithoutAcceptancesInput
  competition: CompetitionUpdateOneRequiredWithoutRegistrationsInput
  competitor: CompetitorUpdateOneRequiredWithoutRegistrationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  paid: BoolFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RegistrationUpsertWithWhereUniqueWithoutAcceptorInput {
  create: RegistrationCreateWithoutAcceptorInput!
  update: RegistrationUpdateWithoutAcceptorInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationUpsertWithWhereUniqueWithoutCompetitionInput {
  create: RegistrationCreateWithoutCompetitionInput!
  update: RegistrationUpdateWithoutCompetitionInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationUpsertWithWhereUniqueWithoutCompetitorInput {
  create: RegistrationCreateWithoutCompetitorInput!
  update: RegistrationUpdateWithoutCompetitorInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationUpsertWithWhereUniqueWithoutRegistrantInput {
  create: RegistrationCreateWithoutRegistrantInput!
  update: RegistrationUpdateWithoutRegistrantInput!
  where: RegistrationWhereUniqueInput!
}

input RegistrationWhereInput {
  AND: [RegistrationWhereInput!]
  NOT: [RegistrationWhereInput!]
  OR: [RegistrationWhereInput!]
  accepted: BoolFilter
  acceptor: UserRelationFilter
  acceptorId: IntFilter
  competition: CompetitionRelationFilter
  competitionId: IntFilter
  competitor: CompetitorRelationFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  paid: BoolFilter
  registrant: UserRelationFilter
  registrantId: IntFilter
  updatedAt: DateTimeFilter
}

input RegistrationWhereUniqueInput {
  id: Int
}

type Result {
  approvedBy: User!
  approvedById: Int!
  competition: Competition!
  competitionId: Int!
  competitor: Competitor!
  competitorId: Int!
  createdAt: DateTime!
  id: Int!
  score: Int!
  updatedAt: DateTime!
}

type ResultAvgAggregate {
  approvedById: Float!
  competitionId: Float!
  competitorId: Float!
  id: Float!
  score: Float!
}

type ResultCountAggregate {
  _all: Int!
  approvedById: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: Int
  id: Int!
  score: Int!
  updatedAt: Int
}

input ResultCreateInput {
  approvedBy: UserCreateNestedOneWithoutResultsInput!
  competition: CompetitionCreateNestedOneWithoutResultsInput!
  competitor: CompetitorCreateNestedOneWithoutResultsInput!
  createdAt: DateTime
  score: Int!
  updatedAt: DateTime
}

input ResultCreateManyApprovedByInput {
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  score: Int!
  updatedAt: DateTime
}

input ResultCreateManyApprovedByInputEnvelope {
  data: [ResultCreateManyApprovedByInput!]!
  skipDuplicates: Boolean
}

input ResultCreateManyCompetitionInput {
  approvedById: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  score: Int!
  updatedAt: DateTime
}

input ResultCreateManyCompetitionInputEnvelope {
  data: [ResultCreateManyCompetitionInput!]!
  skipDuplicates: Boolean
}

input ResultCreateManyCompetitorInput {
  approvedById: Int!
  competitionId: Int!
  createdAt: DateTime
  id: Int
  score: Int!
  updatedAt: DateTime
}

input ResultCreateManyCompetitorInputEnvelope {
  data: [ResultCreateManyCompetitorInput!]!
  skipDuplicates: Boolean
}

input ResultCreateManyInput {
  approvedById: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  score: Int!
  updatedAt: DateTime
}

input ResultCreateNestedManyWithoutApprovedByInput {
  connect: [ResultWhereUniqueInput!]
  connectOrCreate: [ResultCreateOrConnectWithoutApprovedByInput!]
  create: [ResultCreateWithoutApprovedByInput!]
  createMany: ResultCreateManyApprovedByInputEnvelope
}

input ResultCreateNestedManyWithoutCompetitionInput {
  connect: [ResultWhereUniqueInput!]
  connectOrCreate: [ResultCreateOrConnectWithoutCompetitionInput!]
  create: [ResultCreateWithoutCompetitionInput!]
  createMany: ResultCreateManyCompetitionInputEnvelope
}

input ResultCreateNestedManyWithoutCompetitorInput {
  connect: [ResultWhereUniqueInput!]
  connectOrCreate: [ResultCreateOrConnectWithoutCompetitorInput!]
  create: [ResultCreateWithoutCompetitorInput!]
  createMany: ResultCreateManyCompetitorInputEnvelope
}

input ResultCreateOrConnectWithoutApprovedByInput {
  create: ResultCreateWithoutApprovedByInput!
  where: ResultWhereUniqueInput!
}

input ResultCreateOrConnectWithoutCompetitionInput {
  create: ResultCreateWithoutCompetitionInput!
  where: ResultWhereUniqueInput!
}

input ResultCreateOrConnectWithoutCompetitorInput {
  create: ResultCreateWithoutCompetitorInput!
  where: ResultWhereUniqueInput!
}

input ResultCreateWithoutApprovedByInput {
  competition: CompetitionCreateNestedOneWithoutResultsInput!
  competitor: CompetitorCreateNestedOneWithoutResultsInput!
  createdAt: DateTime
  score: Int!
  updatedAt: DateTime
}

input ResultCreateWithoutCompetitionInput {
  approvedBy: UserCreateNestedOneWithoutResultsInput!
  competitor: CompetitorCreateNestedOneWithoutResultsInput!
  createdAt: DateTime
  score: Int!
  updatedAt: DateTime
}

input ResultCreateWithoutCompetitorInput {
  approvedBy: UserCreateNestedOneWithoutResultsInput!
  competition: CompetitionCreateNestedOneWithoutResultsInput!
  createdAt: DateTime
  score: Int!
  updatedAt: DateTime
}

type ResultGroupBy {
  approvedById: Int!
  avg: ResultAvgAggregate
  competitionId: Int!
  competitorId: Int!
  count: ResultCountAggregate
  createdAt: DateTime!
  id: Int!
  max: ResultMaxAggregate
  min: ResultMinAggregate
  score: Int!
  sum: ResultSumAggregate
  updatedAt: DateTime!
}

input ResultListRelationFilter {
  every: ResultWhereInput
  none: ResultWhereInput
  some: ResultWhereInput
}

type ResultMaxAggregate {
  approvedById: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  score: Int!
  updatedAt: DateTime
}

type ResultMinAggregate {
  approvedById: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  score: Int!
  updatedAt: DateTime
}

input ResultOrderByInput {
  approvedById: SortOrder
  competitionId: SortOrder
  competitorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  score: SortOrder
  updatedAt: SortOrder
}

enum ResultScalarFieldEnum {
  approvedById
  competitionId
  competitorId
  createdAt
  id
  score
  updatedAt
}

input ResultScalarWhereInput {
  AND: [ResultScalarWhereInput!]
  NOT: [ResultScalarWhereInput!]
  OR: [ResultScalarWhereInput!]
  approvedById: IntFilter
  competitionId: IntFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  score: IntFilter
  updatedAt: DateTimeFilter
}

input ResultScalarWhereWithAggregatesInput {
  AND: [ResultScalarWhereWithAggregatesInput!]
  NOT: [ResultScalarWhereWithAggregatesInput!]
  OR: [ResultScalarWhereWithAggregatesInput!]
  approvedById: IntWithAggregatesFilter
  competitionId: IntWithAggregatesFilter
  competitorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  score: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ResultSumAggregate {
  approvedById: Int!
  competitionId: Int!
  competitorId: Int!
  id: Int!
  score: Int!
}

input ResultUpdateInput {
  approvedBy: UserUpdateOneRequiredWithoutResultsInput
  competition: CompetitionUpdateOneRequiredWithoutResultsInput
  competitor: CompetitorUpdateOneRequiredWithoutResultsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  score: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  score: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultUpdateManyWithWhereWithoutApprovedByInput {
  data: ResultUpdateManyMutationInput!
  where: ResultScalarWhereInput!
}

input ResultUpdateManyWithWhereWithoutCompetitionInput {
  data: ResultUpdateManyMutationInput!
  where: ResultScalarWhereInput!
}

input ResultUpdateManyWithWhereWithoutCompetitorInput {
  data: ResultUpdateManyMutationInput!
  where: ResultScalarWhereInput!
}

input ResultUpdateManyWithoutApprovedByInput {
  connect: [ResultWhereUniqueInput!]
  connectOrCreate: [ResultCreateOrConnectWithoutApprovedByInput!]
  create: [ResultCreateWithoutApprovedByInput!]
  createMany: ResultCreateManyApprovedByInputEnvelope
  delete: [ResultWhereUniqueInput!]
  deleteMany: [ResultScalarWhereInput!]
  disconnect: [ResultWhereUniqueInput!]
  set: [ResultWhereUniqueInput!]
  update: [ResultUpdateWithWhereUniqueWithoutApprovedByInput!]
  updateMany: [ResultUpdateManyWithWhereWithoutApprovedByInput!]
  upsert: [ResultUpsertWithWhereUniqueWithoutApprovedByInput!]
}

input ResultUpdateManyWithoutCompetitionInput {
  connect: [ResultWhereUniqueInput!]
  connectOrCreate: [ResultCreateOrConnectWithoutCompetitionInput!]
  create: [ResultCreateWithoutCompetitionInput!]
  createMany: ResultCreateManyCompetitionInputEnvelope
  delete: [ResultWhereUniqueInput!]
  deleteMany: [ResultScalarWhereInput!]
  disconnect: [ResultWhereUniqueInput!]
  set: [ResultWhereUniqueInput!]
  update: [ResultUpdateWithWhereUniqueWithoutCompetitionInput!]
  updateMany: [ResultUpdateManyWithWhereWithoutCompetitionInput!]
  upsert: [ResultUpsertWithWhereUniqueWithoutCompetitionInput!]
}

input ResultUpdateManyWithoutCompetitorInput {
  connect: [ResultWhereUniqueInput!]
  connectOrCreate: [ResultCreateOrConnectWithoutCompetitorInput!]
  create: [ResultCreateWithoutCompetitorInput!]
  createMany: ResultCreateManyCompetitorInputEnvelope
  delete: [ResultWhereUniqueInput!]
  deleteMany: [ResultScalarWhereInput!]
  disconnect: [ResultWhereUniqueInput!]
  set: [ResultWhereUniqueInput!]
  update: [ResultUpdateWithWhereUniqueWithoutCompetitorInput!]
  updateMany: [ResultUpdateManyWithWhereWithoutCompetitorInput!]
  upsert: [ResultUpsertWithWhereUniqueWithoutCompetitorInput!]
}

input ResultUpdateWithWhereUniqueWithoutApprovedByInput {
  data: ResultUpdateWithoutApprovedByInput!
  where: ResultWhereUniqueInput!
}

input ResultUpdateWithWhereUniqueWithoutCompetitionInput {
  data: ResultUpdateWithoutCompetitionInput!
  where: ResultWhereUniqueInput!
}

input ResultUpdateWithWhereUniqueWithoutCompetitorInput {
  data: ResultUpdateWithoutCompetitorInput!
  where: ResultWhereUniqueInput!
}

input ResultUpdateWithoutApprovedByInput {
  competition: CompetitionUpdateOneRequiredWithoutResultsInput
  competitor: CompetitorUpdateOneRequiredWithoutResultsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  score: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultUpdateWithoutCompetitionInput {
  approvedBy: UserUpdateOneRequiredWithoutResultsInput
  competitor: CompetitorUpdateOneRequiredWithoutResultsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  score: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultUpdateWithoutCompetitorInput {
  approvedBy: UserUpdateOneRequiredWithoutResultsInput
  competition: CompetitionUpdateOneRequiredWithoutResultsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  score: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ResultUpsertWithWhereUniqueWithoutApprovedByInput {
  create: ResultCreateWithoutApprovedByInput!
  update: ResultUpdateWithoutApprovedByInput!
  where: ResultWhereUniqueInput!
}

input ResultUpsertWithWhereUniqueWithoutCompetitionInput {
  create: ResultCreateWithoutCompetitionInput!
  update: ResultUpdateWithoutCompetitionInput!
  where: ResultWhereUniqueInput!
}

input ResultUpsertWithWhereUniqueWithoutCompetitorInput {
  create: ResultCreateWithoutCompetitorInput!
  update: ResultUpdateWithoutCompetitorInput!
  where: ResultWhereUniqueInput!
}

input ResultWhereInput {
  AND: [ResultWhereInput!]
  NOT: [ResultWhereInput!]
  OR: [ResultWhereInput!]
  approvedBy: UserRelationFilter
  approvedById: IntFilter
  competition: CompetitionRelationFilter
  competitionId: IntFilter
  competitor: CompetitorRelationFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  score: IntFilter
  updatedAt: DateTimeFilter
}

input ResultWhereUniqueInput {
  id: Int
}

type Route {
  active: Boolean!
  category: Category!
  categoryId: Int!
  competition: Competition!
  competitionId: Int!
  createdAt: DateTime!
  description: String
  grade: Grade!
  gradeId: Int!
  id: Int!
  judge: User!
  judgeId: Int!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder(cursor: ScoreBoulderWhereUniqueInput, distinct: [ScoreBoulderScalarFieldEnum!], orderBy: [ScoreBoulderOrderByInput!], skip: Int, take: Int, where: ScoreBoulderWhereInput): [ScoreBoulder!]!
  scoreLead(cursor: ScoreLeadWhereUniqueInput, distinct: [ScoreLeadScalarFieldEnum!], orderBy: [ScoreLeadOrderByInput!], skip: Int, take: Int, where: ScoreLeadWhereInput): [ScoreLead!]!
  scoreSpeed(cursor: ScoreSpeedWhereUniqueInput, distinct: [ScoreSpeedScalarFieldEnum!], orderBy: [ScoreSpeedOrderByInput!], skip: Int, take: Int, where: ScoreSpeedWhereInput): [ScoreSpeed!]!
  setter: User!
  setterId: Int!
  updatedAt: DateTime!
}

type RouteAvgAggregate {
  categoryId: Float!
  competitionId: Float!
  gradeId: Float!
  id: Float!
  judgeId: Float!
  number: Float!
  setterId: Float!
}

type RouteCountAggregate {
  _all: Int!
  active: Int
  categoryId: Int!
  competitionId: Int!
  createdAt: Int
  description: Int
  gradeId: Int!
  id: Int!
  judgeId: Int!
  name: Int
  number: Int!
  routeType: Int
  setterId: Int!
  updatedAt: Int
}

input RouteCreateInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateManyCategoryInput {
  active: Boolean
  competitionId: Int!
  createdAt: DateTime
  description: String
  gradeId: Int!
  id: Int
  judgeId: Int!
  name: String!
  number: Int!
  routeType: RouteType!
  setterId: Int!
  updatedAt: DateTime
}

input RouteCreateManyCategoryInputEnvelope {
  data: [RouteCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input RouteCreateManyCompetitionInput {
  active: Boolean
  categoryId: Int!
  createdAt: DateTime
  description: String
  gradeId: Int!
  id: Int
  judgeId: Int!
  name: String!
  number: Int!
  routeType: RouteType!
  setterId: Int!
  updatedAt: DateTime
}

input RouteCreateManyCompetitionInputEnvelope {
  data: [RouteCreateManyCompetitionInput!]!
  skipDuplicates: Boolean
}

input RouteCreateManyGradeInput {
  active: Boolean
  categoryId: Int!
  competitionId: Int!
  createdAt: DateTime
  description: String
  id: Int
  judgeId: Int!
  name: String!
  number: Int!
  routeType: RouteType!
  setterId: Int!
  updatedAt: DateTime
}

input RouteCreateManyGradeInputEnvelope {
  data: [RouteCreateManyGradeInput!]!
  skipDuplicates: Boolean
}

input RouteCreateManyInput {
  active: Boolean
  categoryId: Int!
  competitionId: Int!
  createdAt: DateTime
  description: String
  gradeId: Int!
  id: Int
  judgeId: Int!
  name: String!
  number: Int!
  routeType: RouteType!
  setterId: Int!
  updatedAt: DateTime
}

input RouteCreateManyJudgeInput {
  active: Boolean
  categoryId: Int!
  competitionId: Int!
  createdAt: DateTime
  description: String
  gradeId: Int!
  id: Int
  name: String!
  number: Int!
  routeType: RouteType!
  setterId: Int!
  updatedAt: DateTime
}

input RouteCreateManyJudgeInputEnvelope {
  data: [RouteCreateManyJudgeInput!]!
  skipDuplicates: Boolean
}

input RouteCreateManySetterInput {
  active: Boolean
  categoryId: Int!
  competitionId: Int!
  createdAt: DateTime
  description: String
  gradeId: Int!
  id: Int
  judgeId: Int!
  name: String!
  number: Int!
  routeType: RouteType!
  updatedAt: DateTime
}

input RouteCreateManySetterInputEnvelope {
  data: [RouteCreateManySetterInput!]!
  skipDuplicates: Boolean
}

input RouteCreateNestedManyWithoutCategoryInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutCategoryInput!]
  create: [RouteCreateWithoutCategoryInput!]
  createMany: RouteCreateManyCategoryInputEnvelope
}

input RouteCreateNestedManyWithoutCompetitionInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutCompetitionInput!]
  create: [RouteCreateWithoutCompetitionInput!]
  createMany: RouteCreateManyCompetitionInputEnvelope
}

input RouteCreateNestedManyWithoutGradeInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutGradeInput!]
  create: [RouteCreateWithoutGradeInput!]
  createMany: RouteCreateManyGradeInputEnvelope
}

input RouteCreateNestedManyWithoutJudgeInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutJudgeInput!]
  create: [RouteCreateWithoutJudgeInput!]
  createMany: RouteCreateManyJudgeInputEnvelope
}

input RouteCreateNestedManyWithoutSetterInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutSetterInput!]
  create: [RouteCreateWithoutSetterInput!]
  createMany: RouteCreateManySetterInputEnvelope
}

input RouteCreateNestedOneWithoutScoreBoulderInput {
  connect: RouteWhereUniqueInput
  connectOrCreate: RouteCreateOrConnectWithoutScoreBoulderInput
  create: RouteCreateWithoutScoreBoulderInput
}

input RouteCreateNestedOneWithoutScoreLeadInput {
  connect: RouteWhereUniqueInput
  connectOrCreate: RouteCreateOrConnectWithoutScoreLeadInput
  create: RouteCreateWithoutScoreLeadInput
}

input RouteCreateNestedOneWithoutScoreSpeedInput {
  connect: RouteWhereUniqueInput
  connectOrCreate: RouteCreateOrConnectWithoutScoreSpeedInput
  create: RouteCreateWithoutScoreSpeedInput
}

input RouteCreateOrConnectWithoutCategoryInput {
  create: RouteCreateWithoutCategoryInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateOrConnectWithoutCompetitionInput {
  create: RouteCreateWithoutCompetitionInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateOrConnectWithoutGradeInput {
  create: RouteCreateWithoutGradeInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateOrConnectWithoutJudgeInput {
  create: RouteCreateWithoutJudgeInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateOrConnectWithoutScoreBoulderInput {
  create: RouteCreateWithoutScoreBoulderInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateOrConnectWithoutScoreLeadInput {
  create: RouteCreateWithoutScoreLeadInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateOrConnectWithoutScoreSpeedInput {
  create: RouteCreateWithoutScoreSpeedInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateOrConnectWithoutSetterInput {
  create: RouteCreateWithoutSetterInput!
  where: RouteWhereUniqueInput!
}

input RouteCreateWithoutCategoryInput {
  active: Boolean
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateWithoutCompetitionInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateWithoutGradeInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateWithoutJudgeInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateWithoutScoreBoulderInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateWithoutScoreLeadInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateWithoutScoreSpeedInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  setter: UserCreateNestedOneWithoutRoutesSetInput!
  updatedAt: DateTime
}

input RouteCreateWithoutSetterInput {
  active: Boolean
  category: CategoryCreateNestedOneWithoutRoutesInput!
  competition: CompetitionCreateNestedOneWithoutRoutesInput!
  createdAt: DateTime
  description: String
  grade: GradeCreateNestedOneWithoutRoutesInput!
  judge: UserCreateNestedOneWithoutRoutesJudgedInput!
  name: String!
  number: Int!
  routeType: RouteType!
  scoreBoulder: ScoreBoulderCreateNestedManyWithoutRouteInput
  scoreLead: ScoreLeadCreateNestedManyWithoutRouteInput
  scoreSpeed: ScoreSpeedCreateNestedManyWithoutRouteInput
  updatedAt: DateTime
}

type RouteGroupBy {
  active: Boolean!
  avg: RouteAvgAggregate
  categoryId: Int!
  competitionId: Int!
  count: RouteCountAggregate
  createdAt: DateTime!
  description: String
  gradeId: Int!
  id: Int!
  judgeId: Int!
  max: RouteMaxAggregate
  min: RouteMinAggregate
  name: String!
  number: Int!
  routeType: RouteType!
  setterId: Int!
  sum: RouteSumAggregate
  updatedAt: DateTime!
}

input RouteListRelationFilter {
  every: RouteWhereInput
  none: RouteWhereInput
  some: RouteWhereInput
}

type RouteMaxAggregate {
  active: Boolean
  categoryId: Int!
  competitionId: Int!
  createdAt: DateTime
  description: String
  gradeId: Int!
  id: Int!
  judgeId: Int!
  name: String
  number: Int!
  routeType: RouteType
  setterId: Int!
  updatedAt: DateTime
}

type RouteMinAggregate {
  active: Boolean
  categoryId: Int!
  competitionId: Int!
  createdAt: DateTime
  description: String
  gradeId: Int!
  id: Int!
  judgeId: Int!
  name: String
  number: Int!
  routeType: RouteType
  setterId: Int!
  updatedAt: DateTime
}

input RouteOrderByInput {
  active: SortOrder
  categoryId: SortOrder
  competitionId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  gradeId: SortOrder
  id: SortOrder
  judgeId: SortOrder
  name: SortOrder
  number: SortOrder
  routeType: SortOrder
  setterId: SortOrder
  updatedAt: SortOrder
}

input RouteRelationFilter {
  is: RouteWhereInput
  isNot: RouteWhereInput
}

enum RouteScalarFieldEnum {
  active
  categoryId
  competitionId
  createdAt
  description
  gradeId
  id
  judgeId
  name
  number
  routeType
  setterId
  updatedAt
}

input RouteScalarWhereInput {
  AND: [RouteScalarWhereInput!]
  NOT: [RouteScalarWhereInput!]
  OR: [RouteScalarWhereInput!]
  active: BoolFilter
  categoryId: IntFilter
  competitionId: IntFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  gradeId: IntFilter
  id: IntFilter
  judgeId: IntFilter
  name: StringFilter
  number: IntFilter
  routeType: EnumRouteTypeFilter
  setterId: IntFilter
  updatedAt: DateTimeFilter
}

input RouteScalarWhereWithAggregatesInput {
  AND: [RouteScalarWhereWithAggregatesInput!]
  NOT: [RouteScalarWhereWithAggregatesInput!]
  OR: [RouteScalarWhereWithAggregatesInput!]
  active: BoolWithAggregatesFilter
  categoryId: IntWithAggregatesFilter
  competitionId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  gradeId: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  judgeId: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  number: IntWithAggregatesFilter
  routeType: EnumRouteTypeWithAggregatesFilter
  setterId: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type RouteSumAggregate {
  categoryId: Int!
  competitionId: Int!
  gradeId: Int!
  id: Int!
  judgeId: Int!
  number: Int!
  setterId: Int!
}

enum RouteType {
  BOULDER
  DUEL
  LEAD
  SPEED
}

input RouteUpdateInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateManyMutationInput {
  active: BoolFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateManyWithWhereWithoutCategoryInput {
  data: RouteUpdateManyMutationInput!
  where: RouteScalarWhereInput!
}

input RouteUpdateManyWithWhereWithoutCompetitionInput {
  data: RouteUpdateManyMutationInput!
  where: RouteScalarWhereInput!
}

input RouteUpdateManyWithWhereWithoutGradeInput {
  data: RouteUpdateManyMutationInput!
  where: RouteScalarWhereInput!
}

input RouteUpdateManyWithWhereWithoutJudgeInput {
  data: RouteUpdateManyMutationInput!
  where: RouteScalarWhereInput!
}

input RouteUpdateManyWithWhereWithoutSetterInput {
  data: RouteUpdateManyMutationInput!
  where: RouteScalarWhereInput!
}

input RouteUpdateManyWithoutCategoryInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutCategoryInput!]
  create: [RouteCreateWithoutCategoryInput!]
  createMany: RouteCreateManyCategoryInputEnvelope
  delete: [RouteWhereUniqueInput!]
  deleteMany: [RouteScalarWhereInput!]
  disconnect: [RouteWhereUniqueInput!]
  set: [RouteWhereUniqueInput!]
  update: [RouteUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [RouteUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [RouteUpsertWithWhereUniqueWithoutCategoryInput!]
}

input RouteUpdateManyWithoutCompetitionInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutCompetitionInput!]
  create: [RouteCreateWithoutCompetitionInput!]
  createMany: RouteCreateManyCompetitionInputEnvelope
  delete: [RouteWhereUniqueInput!]
  deleteMany: [RouteScalarWhereInput!]
  disconnect: [RouteWhereUniqueInput!]
  set: [RouteWhereUniqueInput!]
  update: [RouteUpdateWithWhereUniqueWithoutCompetitionInput!]
  updateMany: [RouteUpdateManyWithWhereWithoutCompetitionInput!]
  upsert: [RouteUpsertWithWhereUniqueWithoutCompetitionInput!]
}

input RouteUpdateManyWithoutGradeInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutGradeInput!]
  create: [RouteCreateWithoutGradeInput!]
  createMany: RouteCreateManyGradeInputEnvelope
  delete: [RouteWhereUniqueInput!]
  deleteMany: [RouteScalarWhereInput!]
  disconnect: [RouteWhereUniqueInput!]
  set: [RouteWhereUniqueInput!]
  update: [RouteUpdateWithWhereUniqueWithoutGradeInput!]
  updateMany: [RouteUpdateManyWithWhereWithoutGradeInput!]
  upsert: [RouteUpsertWithWhereUniqueWithoutGradeInput!]
}

input RouteUpdateManyWithoutJudgeInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutJudgeInput!]
  create: [RouteCreateWithoutJudgeInput!]
  createMany: RouteCreateManyJudgeInputEnvelope
  delete: [RouteWhereUniqueInput!]
  deleteMany: [RouteScalarWhereInput!]
  disconnect: [RouteWhereUniqueInput!]
  set: [RouteWhereUniqueInput!]
  update: [RouteUpdateWithWhereUniqueWithoutJudgeInput!]
  updateMany: [RouteUpdateManyWithWhereWithoutJudgeInput!]
  upsert: [RouteUpsertWithWhereUniqueWithoutJudgeInput!]
}

input RouteUpdateManyWithoutSetterInput {
  connect: [RouteWhereUniqueInput!]
  connectOrCreate: [RouteCreateOrConnectWithoutSetterInput!]
  create: [RouteCreateWithoutSetterInput!]
  createMany: RouteCreateManySetterInputEnvelope
  delete: [RouteWhereUniqueInput!]
  deleteMany: [RouteScalarWhereInput!]
  disconnect: [RouteWhereUniqueInput!]
  set: [RouteWhereUniqueInput!]
  update: [RouteUpdateWithWhereUniqueWithoutSetterInput!]
  updateMany: [RouteUpdateManyWithWhereWithoutSetterInput!]
  upsert: [RouteUpsertWithWhereUniqueWithoutSetterInput!]
}

input RouteUpdateOneRequiredWithoutScoreBoulderInput {
  connect: RouteWhereUniqueInput
  connectOrCreate: RouteCreateOrConnectWithoutScoreBoulderInput
  create: RouteCreateWithoutScoreBoulderInput
  update: RouteUpdateWithoutScoreBoulderInput
  upsert: RouteUpsertWithoutScoreBoulderInput
}

input RouteUpdateOneRequiredWithoutScoreLeadInput {
  connect: RouteWhereUniqueInput
  connectOrCreate: RouteCreateOrConnectWithoutScoreLeadInput
  create: RouteCreateWithoutScoreLeadInput
  update: RouteUpdateWithoutScoreLeadInput
  upsert: RouteUpsertWithoutScoreLeadInput
}

input RouteUpdateOneRequiredWithoutScoreSpeedInput {
  connect: RouteWhereUniqueInput
  connectOrCreate: RouteCreateOrConnectWithoutScoreSpeedInput
  create: RouteCreateWithoutScoreSpeedInput
  update: RouteUpdateWithoutScoreSpeedInput
  upsert: RouteUpsertWithoutScoreSpeedInput
}

input RouteUpdateWithWhereUniqueWithoutCategoryInput {
  data: RouteUpdateWithoutCategoryInput!
  where: RouteWhereUniqueInput!
}

input RouteUpdateWithWhereUniqueWithoutCompetitionInput {
  data: RouteUpdateWithoutCompetitionInput!
  where: RouteWhereUniqueInput!
}

input RouteUpdateWithWhereUniqueWithoutGradeInput {
  data: RouteUpdateWithoutGradeInput!
  where: RouteWhereUniqueInput!
}

input RouteUpdateWithWhereUniqueWithoutJudgeInput {
  data: RouteUpdateWithoutJudgeInput!
  where: RouteWhereUniqueInput!
}

input RouteUpdateWithWhereUniqueWithoutSetterInput {
  data: RouteUpdateWithoutSetterInput!
  where: RouteWhereUniqueInput!
}

input RouteUpdateWithoutCategoryInput {
  active: BoolFieldUpdateOperationsInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateWithoutCompetitionInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateWithoutGradeInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateWithoutJudgeInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateWithoutScoreBoulderInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateWithoutScoreLeadInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateWithoutScoreSpeedInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  setter: UserUpdateOneRequiredWithoutRoutesSetInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpdateWithoutSetterInput {
  active: BoolFieldUpdateOperationsInput
  category: CategoryUpdateOneRequiredWithoutRoutesInput
  competition: CompetitionUpdateOneRequiredWithoutRoutesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: GradeUpdateOneRequiredWithoutRoutesInput
  judge: UserUpdateOneRequiredWithoutRoutesJudgedInput
  name: StringFieldUpdateOperationsInput
  number: IntFieldUpdateOperationsInput
  routeType: EnumRouteTypeFieldUpdateOperationsInput
  scoreBoulder: ScoreBoulderUpdateManyWithoutRouteInput
  scoreLead: ScoreLeadUpdateManyWithoutRouteInput
  scoreSpeed: ScoreSpeedUpdateManyWithoutRouteInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input RouteUpsertWithWhereUniqueWithoutCategoryInput {
  create: RouteCreateWithoutCategoryInput!
  update: RouteUpdateWithoutCategoryInput!
  where: RouteWhereUniqueInput!
}

input RouteUpsertWithWhereUniqueWithoutCompetitionInput {
  create: RouteCreateWithoutCompetitionInput!
  update: RouteUpdateWithoutCompetitionInput!
  where: RouteWhereUniqueInput!
}

input RouteUpsertWithWhereUniqueWithoutGradeInput {
  create: RouteCreateWithoutGradeInput!
  update: RouteUpdateWithoutGradeInput!
  where: RouteWhereUniqueInput!
}

input RouteUpsertWithWhereUniqueWithoutJudgeInput {
  create: RouteCreateWithoutJudgeInput!
  update: RouteUpdateWithoutJudgeInput!
  where: RouteWhereUniqueInput!
}

input RouteUpsertWithWhereUniqueWithoutSetterInput {
  create: RouteCreateWithoutSetterInput!
  update: RouteUpdateWithoutSetterInput!
  where: RouteWhereUniqueInput!
}

input RouteUpsertWithoutScoreBoulderInput {
  create: RouteCreateWithoutScoreBoulderInput!
  update: RouteUpdateWithoutScoreBoulderInput!
}

input RouteUpsertWithoutScoreLeadInput {
  create: RouteCreateWithoutScoreLeadInput!
  update: RouteUpdateWithoutScoreLeadInput!
}

input RouteUpsertWithoutScoreSpeedInput {
  create: RouteCreateWithoutScoreSpeedInput!
  update: RouteUpdateWithoutScoreSpeedInput!
}

input RouteWhereInput {
  AND: [RouteWhereInput!]
  NOT: [RouteWhereInput!]
  OR: [RouteWhereInput!]
  active: BoolFilter
  category: CategoryRelationFilter
  categoryId: IntFilter
  competition: CompetitionRelationFilter
  competitionId: IntFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  grade: GradeRelationFilter
  gradeId: IntFilter
  id: IntFilter
  judge: UserRelationFilter
  judgeId: IntFilter
  name: StringFilter
  number: IntFilter
  routeType: EnumRouteTypeFilter
  scoreBoulder: ScoreBoulderListRelationFilter
  scoreLead: ScoreLeadListRelationFilter
  scoreSpeed: ScoreSpeedListRelationFilter
  setter: UserRelationFilter
  setterId: IntFilter
  updatedAt: DateTimeFilter
}

input RouteWhereUniqueInput {
  id: Int
}

type ScoreBoulder {
  attempts: Int!
  comment: Comment
  commentId: Int
  competitor: Competitor!
  competitorId: Int!
  createdAt: DateTime!
  id: Int!
  route: Route!
  routeId: Int!
  time: Int
  top: Int!
  updatedAt: DateTime!
  zone: Int!
}

type ScoreBoulderAvgAggregate {
  attempts: Float!
  commentId: Float
  competitorId: Float!
  id: Float!
  routeId: Float!
  time: Float
  top: Float!
  zone: Float!
}

type ScoreBoulderCountAggregate {
  _all: Int!
  attempts: Int!
  commentId: Int
  competitorId: Int!
  createdAt: Int
  id: Int!
  routeId: Int!
  time: Int
  top: Int!
  updatedAt: Int
  zone: Int!
}

input ScoreBoulderCreateInput {
  attempts: Int!
  comment: CommentCreateNestedOneWithoutScoresBoulderInput
  competitor: CompetitorCreateNestedOneWithoutScoresBoulderInput!
  createdAt: DateTime
  route: RouteCreateNestedOneWithoutScoreBoulderInput!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderCreateManyCommentInput {
  attempts: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  routeId: Int!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderCreateManyCommentInputEnvelope {
  data: [ScoreBoulderCreateManyCommentInput!]!
  skipDuplicates: Boolean
}

input ScoreBoulderCreateManyCompetitorInput {
  attempts: Int!
  commentId: Int
  createdAt: DateTime
  id: Int
  routeId: Int!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderCreateManyCompetitorInputEnvelope {
  data: [ScoreBoulderCreateManyCompetitorInput!]!
  skipDuplicates: Boolean
}

input ScoreBoulderCreateManyInput {
  attempts: Int!
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int
  routeId: Int!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderCreateManyRouteInput {
  attempts: Int!
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderCreateManyRouteInputEnvelope {
  data: [ScoreBoulderCreateManyRouteInput!]!
  skipDuplicates: Boolean
}

input ScoreBoulderCreateNestedManyWithoutCommentInput {
  connect: [ScoreBoulderWhereUniqueInput!]
  connectOrCreate: [ScoreBoulderCreateOrConnectWithoutCommentInput!]
  create: [ScoreBoulderCreateWithoutCommentInput!]
  createMany: ScoreBoulderCreateManyCommentInputEnvelope
}

input ScoreBoulderCreateNestedManyWithoutCompetitorInput {
  connect: [ScoreBoulderWhereUniqueInput!]
  connectOrCreate: [ScoreBoulderCreateOrConnectWithoutCompetitorInput!]
  create: [ScoreBoulderCreateWithoutCompetitorInput!]
  createMany: ScoreBoulderCreateManyCompetitorInputEnvelope
}

input ScoreBoulderCreateNestedManyWithoutRouteInput {
  connect: [ScoreBoulderWhereUniqueInput!]
  connectOrCreate: [ScoreBoulderCreateOrConnectWithoutRouteInput!]
  create: [ScoreBoulderCreateWithoutRouteInput!]
  createMany: ScoreBoulderCreateManyRouteInputEnvelope
}

input ScoreBoulderCreateOrConnectWithoutCommentInput {
  create: ScoreBoulderCreateWithoutCommentInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderCreateOrConnectWithoutCompetitorInput {
  create: ScoreBoulderCreateWithoutCompetitorInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderCreateOrConnectWithoutRouteInput {
  create: ScoreBoulderCreateWithoutRouteInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderCreateWithoutCommentInput {
  attempts: Int!
  competitor: CompetitorCreateNestedOneWithoutScoresBoulderInput!
  createdAt: DateTime
  route: RouteCreateNestedOneWithoutScoreBoulderInput!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderCreateWithoutCompetitorInput {
  attempts: Int!
  comment: CommentCreateNestedOneWithoutScoresBoulderInput
  createdAt: DateTime
  route: RouteCreateNestedOneWithoutScoreBoulderInput!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderCreateWithoutRouteInput {
  attempts: Int!
  comment: CommentCreateNestedOneWithoutScoresBoulderInput
  competitor: CompetitorCreateNestedOneWithoutScoresBoulderInput!
  createdAt: DateTime
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

type ScoreBoulderGroupBy {
  attempts: Int!
  avg: ScoreBoulderAvgAggregate
  commentId: Int
  competitorId: Int!
  count: ScoreBoulderCountAggregate
  createdAt: DateTime!
  id: Int!
  max: ScoreBoulderMaxAggregate
  min: ScoreBoulderMinAggregate
  routeId: Int!
  sum: ScoreBoulderSumAggregate
  time: Int
  top: Int!
  updatedAt: DateTime!
  zone: Int!
}

input ScoreBoulderListRelationFilter {
  every: ScoreBoulderWhereInput
  none: ScoreBoulderWhereInput
  some: ScoreBoulderWhereInput
}

type ScoreBoulderMaxAggregate {
  attempts: Int!
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  routeId: Int!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

type ScoreBoulderMinAggregate {
  attempts: Int!
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  routeId: Int!
  time: Int
  top: Int!
  updatedAt: DateTime
  zone: Int!
}

input ScoreBoulderOrderByInput {
  attempts: SortOrder
  commentId: SortOrder
  competitorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  routeId: SortOrder
  time: SortOrder
  top: SortOrder
  updatedAt: SortOrder
  zone: SortOrder
}

enum ScoreBoulderScalarFieldEnum {
  attempts
  commentId
  competitorId
  createdAt
  id
  routeId
  time
  top
  updatedAt
  zone
}

input ScoreBoulderScalarWhereInput {
  AND: [ScoreBoulderScalarWhereInput!]
  NOT: [ScoreBoulderScalarWhereInput!]
  OR: [ScoreBoulderScalarWhereInput!]
  attempts: IntFilter
  commentId: IntNullableFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  routeId: IntFilter
  time: IntNullableFilter
  top: IntFilter
  updatedAt: DateTimeFilter
  zone: IntFilter
}

input ScoreBoulderScalarWhereWithAggregatesInput {
  AND: [ScoreBoulderScalarWhereWithAggregatesInput!]
  NOT: [ScoreBoulderScalarWhereWithAggregatesInput!]
  OR: [ScoreBoulderScalarWhereWithAggregatesInput!]
  attempts: IntWithAggregatesFilter
  commentId: IntNullableWithAggregatesFilter
  competitorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  routeId: IntWithAggregatesFilter
  time: IntNullableWithAggregatesFilter
  top: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  zone: IntWithAggregatesFilter
}

type ScoreBoulderSumAggregate {
  attempts: Int!
  commentId: Int
  competitorId: Int!
  id: Int!
  routeId: Int!
  time: Int
  top: Int!
  zone: Int!
}

input ScoreBoulderUpdateInput {
  attempts: IntFieldUpdateOperationsInput
  comment: CommentUpdateOneWithoutScoresBoulderInput
  competitor: CompetitorUpdateOneRequiredWithoutScoresBoulderInput
  createdAt: DateTimeFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreBoulderInput
  time: NullableIntFieldUpdateOperationsInput
  top: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zone: IntFieldUpdateOperationsInput
}

input ScoreBoulderUpdateManyMutationInput {
  attempts: IntFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  time: NullableIntFieldUpdateOperationsInput
  top: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zone: IntFieldUpdateOperationsInput
}

input ScoreBoulderUpdateManyWithWhereWithoutCommentInput {
  data: ScoreBoulderUpdateManyMutationInput!
  where: ScoreBoulderScalarWhereInput!
}

input ScoreBoulderUpdateManyWithWhereWithoutCompetitorInput {
  data: ScoreBoulderUpdateManyMutationInput!
  where: ScoreBoulderScalarWhereInput!
}

input ScoreBoulderUpdateManyWithWhereWithoutRouteInput {
  data: ScoreBoulderUpdateManyMutationInput!
  where: ScoreBoulderScalarWhereInput!
}

input ScoreBoulderUpdateManyWithoutCommentInput {
  connect: [ScoreBoulderWhereUniqueInput!]
  connectOrCreate: [ScoreBoulderCreateOrConnectWithoutCommentInput!]
  create: [ScoreBoulderCreateWithoutCommentInput!]
  createMany: ScoreBoulderCreateManyCommentInputEnvelope
  delete: [ScoreBoulderWhereUniqueInput!]
  deleteMany: [ScoreBoulderScalarWhereInput!]
  disconnect: [ScoreBoulderWhereUniqueInput!]
  set: [ScoreBoulderWhereUniqueInput!]
  update: [ScoreBoulderUpdateWithWhereUniqueWithoutCommentInput!]
  updateMany: [ScoreBoulderUpdateManyWithWhereWithoutCommentInput!]
  upsert: [ScoreBoulderUpsertWithWhereUniqueWithoutCommentInput!]
}

input ScoreBoulderUpdateManyWithoutCompetitorInput {
  connect: [ScoreBoulderWhereUniqueInput!]
  connectOrCreate: [ScoreBoulderCreateOrConnectWithoutCompetitorInput!]
  create: [ScoreBoulderCreateWithoutCompetitorInput!]
  createMany: ScoreBoulderCreateManyCompetitorInputEnvelope
  delete: [ScoreBoulderWhereUniqueInput!]
  deleteMany: [ScoreBoulderScalarWhereInput!]
  disconnect: [ScoreBoulderWhereUniqueInput!]
  set: [ScoreBoulderWhereUniqueInput!]
  update: [ScoreBoulderUpdateWithWhereUniqueWithoutCompetitorInput!]
  updateMany: [ScoreBoulderUpdateManyWithWhereWithoutCompetitorInput!]
  upsert: [ScoreBoulderUpsertWithWhereUniqueWithoutCompetitorInput!]
}

input ScoreBoulderUpdateManyWithoutRouteInput {
  connect: [ScoreBoulderWhereUniqueInput!]
  connectOrCreate: [ScoreBoulderCreateOrConnectWithoutRouteInput!]
  create: [ScoreBoulderCreateWithoutRouteInput!]
  createMany: ScoreBoulderCreateManyRouteInputEnvelope
  delete: [ScoreBoulderWhereUniqueInput!]
  deleteMany: [ScoreBoulderScalarWhereInput!]
  disconnect: [ScoreBoulderWhereUniqueInput!]
  set: [ScoreBoulderWhereUniqueInput!]
  update: [ScoreBoulderUpdateWithWhereUniqueWithoutRouteInput!]
  updateMany: [ScoreBoulderUpdateManyWithWhereWithoutRouteInput!]
  upsert: [ScoreBoulderUpsertWithWhereUniqueWithoutRouteInput!]
}

input ScoreBoulderUpdateWithWhereUniqueWithoutCommentInput {
  data: ScoreBoulderUpdateWithoutCommentInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderUpdateWithWhereUniqueWithoutCompetitorInput {
  data: ScoreBoulderUpdateWithoutCompetitorInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderUpdateWithWhereUniqueWithoutRouteInput {
  data: ScoreBoulderUpdateWithoutRouteInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderUpdateWithoutCommentInput {
  attempts: IntFieldUpdateOperationsInput
  competitor: CompetitorUpdateOneRequiredWithoutScoresBoulderInput
  createdAt: DateTimeFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreBoulderInput
  time: NullableIntFieldUpdateOperationsInput
  top: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zone: IntFieldUpdateOperationsInput
}

input ScoreBoulderUpdateWithoutCompetitorInput {
  attempts: IntFieldUpdateOperationsInput
  comment: CommentUpdateOneWithoutScoresBoulderInput
  createdAt: DateTimeFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreBoulderInput
  time: NullableIntFieldUpdateOperationsInput
  top: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zone: IntFieldUpdateOperationsInput
}

input ScoreBoulderUpdateWithoutRouteInput {
  attempts: IntFieldUpdateOperationsInput
  comment: CommentUpdateOneWithoutScoresBoulderInput
  competitor: CompetitorUpdateOneRequiredWithoutScoresBoulderInput
  createdAt: DateTimeFieldUpdateOperationsInput
  time: NullableIntFieldUpdateOperationsInput
  top: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  zone: IntFieldUpdateOperationsInput
}

input ScoreBoulderUpsertWithWhereUniqueWithoutCommentInput {
  create: ScoreBoulderCreateWithoutCommentInput!
  update: ScoreBoulderUpdateWithoutCommentInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderUpsertWithWhereUniqueWithoutCompetitorInput {
  create: ScoreBoulderCreateWithoutCompetitorInput!
  update: ScoreBoulderUpdateWithoutCompetitorInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderUpsertWithWhereUniqueWithoutRouteInput {
  create: ScoreBoulderCreateWithoutRouteInput!
  update: ScoreBoulderUpdateWithoutRouteInput!
  where: ScoreBoulderWhereUniqueInput!
}

input ScoreBoulderWhereInput {
  AND: [ScoreBoulderWhereInput!]
  NOT: [ScoreBoulderWhereInput!]
  OR: [ScoreBoulderWhereInput!]
  attempts: IntFilter
  comment: CommentRelationFilter
  commentId: IntNullableFilter
  competitor: CompetitorRelationFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  route: RouteRelationFilter
  routeId: IntFilter
  time: IntNullableFilter
  top: IntFilter
  updatedAt: DateTimeFilter
  zone: IntFilter
}

input ScoreBoulderWhereUniqueInput {
  id: Int
}

type ScoreLead {
  comment: Comment
  commentId: Int
  competitor: Competitor!
  competitorId: Int!
  createdAt: DateTime!
  height: Int!
  id: Int!
  route: Route!
  routeId: Int!
  time: Int!
  updatedAt: DateTime!
}

type ScoreLeadAvgAggregate {
  commentId: Float
  competitorId: Float!
  height: Float!
  id: Float!
  routeId: Float!
  time: Float!
}

type ScoreLeadCountAggregate {
  _all: Int!
  commentId: Int
  competitorId: Int!
  createdAt: Int
  height: Int!
  id: Int!
  routeId: Int!
  time: Int!
  updatedAt: Int
}

input ScoreLeadCreateInput {
  comment: CommentCreateNestedOneWithoutScoresLeadInput
  competitor: CompetitorCreateNestedOneWithoutScoresLeadInput!
  createdAt: DateTime
  height: Int!
  route: RouteCreateNestedOneWithoutScoreLeadInput!
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadCreateManyCommentInput {
  competitorId: Int!
  createdAt: DateTime
  height: Int!
  id: Int
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadCreateManyCommentInputEnvelope {
  data: [ScoreLeadCreateManyCommentInput!]!
  skipDuplicates: Boolean
}

input ScoreLeadCreateManyCompetitorInput {
  commentId: Int
  createdAt: DateTime
  height: Int!
  id: Int
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadCreateManyCompetitorInputEnvelope {
  data: [ScoreLeadCreateManyCompetitorInput!]!
  skipDuplicates: Boolean
}

input ScoreLeadCreateManyInput {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  height: Int!
  id: Int
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadCreateManyRouteInput {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  height: Int!
  id: Int
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadCreateManyRouteInputEnvelope {
  data: [ScoreLeadCreateManyRouteInput!]!
  skipDuplicates: Boolean
}

input ScoreLeadCreateNestedManyWithoutCommentInput {
  connect: [ScoreLeadWhereUniqueInput!]
  connectOrCreate: [ScoreLeadCreateOrConnectWithoutCommentInput!]
  create: [ScoreLeadCreateWithoutCommentInput!]
  createMany: ScoreLeadCreateManyCommentInputEnvelope
}

input ScoreLeadCreateNestedManyWithoutCompetitorInput {
  connect: [ScoreLeadWhereUniqueInput!]
  connectOrCreate: [ScoreLeadCreateOrConnectWithoutCompetitorInput!]
  create: [ScoreLeadCreateWithoutCompetitorInput!]
  createMany: ScoreLeadCreateManyCompetitorInputEnvelope
}

input ScoreLeadCreateNestedManyWithoutRouteInput {
  connect: [ScoreLeadWhereUniqueInput!]
  connectOrCreate: [ScoreLeadCreateOrConnectWithoutRouteInput!]
  create: [ScoreLeadCreateWithoutRouteInput!]
  createMany: ScoreLeadCreateManyRouteInputEnvelope
}

input ScoreLeadCreateOrConnectWithoutCommentInput {
  create: ScoreLeadCreateWithoutCommentInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadCreateOrConnectWithoutCompetitorInput {
  create: ScoreLeadCreateWithoutCompetitorInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadCreateOrConnectWithoutRouteInput {
  create: ScoreLeadCreateWithoutRouteInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadCreateWithoutCommentInput {
  competitor: CompetitorCreateNestedOneWithoutScoresLeadInput!
  createdAt: DateTime
  height: Int!
  route: RouteCreateNestedOneWithoutScoreLeadInput!
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadCreateWithoutCompetitorInput {
  comment: CommentCreateNestedOneWithoutScoresLeadInput
  createdAt: DateTime
  height: Int!
  route: RouteCreateNestedOneWithoutScoreLeadInput!
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadCreateWithoutRouteInput {
  comment: CommentCreateNestedOneWithoutScoresLeadInput
  competitor: CompetitorCreateNestedOneWithoutScoresLeadInput!
  createdAt: DateTime
  height: Int!
  time: Int!
  updatedAt: DateTime
}

type ScoreLeadGroupBy {
  avg: ScoreLeadAvgAggregate
  commentId: Int
  competitorId: Int!
  count: ScoreLeadCountAggregate
  createdAt: DateTime!
  height: Int!
  id: Int!
  max: ScoreLeadMaxAggregate
  min: ScoreLeadMinAggregate
  routeId: Int!
  sum: ScoreLeadSumAggregate
  time: Int!
  updatedAt: DateTime!
}

input ScoreLeadListRelationFilter {
  every: ScoreLeadWhereInput
  none: ScoreLeadWhereInput
  some: ScoreLeadWhereInput
}

type ScoreLeadMaxAggregate {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  height: Int!
  id: Int!
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

type ScoreLeadMinAggregate {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  height: Int!
  id: Int!
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreLeadOrderByInput {
  commentId: SortOrder
  competitorId: SortOrder
  createdAt: SortOrder
  height: SortOrder
  id: SortOrder
  routeId: SortOrder
  time: SortOrder
  updatedAt: SortOrder
}

enum ScoreLeadScalarFieldEnum {
  commentId
  competitorId
  createdAt
  height
  id
  routeId
  time
  updatedAt
}

input ScoreLeadScalarWhereInput {
  AND: [ScoreLeadScalarWhereInput!]
  NOT: [ScoreLeadScalarWhereInput!]
  OR: [ScoreLeadScalarWhereInput!]
  commentId: IntNullableFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  height: IntFilter
  id: IntFilter
  routeId: IntFilter
  time: IntFilter
  updatedAt: DateTimeFilter
}

input ScoreLeadScalarWhereWithAggregatesInput {
  AND: [ScoreLeadScalarWhereWithAggregatesInput!]
  NOT: [ScoreLeadScalarWhereWithAggregatesInput!]
  OR: [ScoreLeadScalarWhereWithAggregatesInput!]
  commentId: IntNullableWithAggregatesFilter
  competitorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  height: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  routeId: IntWithAggregatesFilter
  time: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ScoreLeadSumAggregate {
  commentId: Int
  competitorId: Int!
  height: Int!
  id: Int!
  routeId: Int!
  time: Int!
}

input ScoreLeadUpdateInput {
  comment: CommentUpdateOneWithoutScoresLeadInput
  competitor: CompetitorUpdateOneRequiredWithoutScoresLeadInput
  createdAt: DateTimeFieldUpdateOperationsInput
  height: IntFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreLeadInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreLeadUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  height: IntFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreLeadUpdateManyWithWhereWithoutCommentInput {
  data: ScoreLeadUpdateManyMutationInput!
  where: ScoreLeadScalarWhereInput!
}

input ScoreLeadUpdateManyWithWhereWithoutCompetitorInput {
  data: ScoreLeadUpdateManyMutationInput!
  where: ScoreLeadScalarWhereInput!
}

input ScoreLeadUpdateManyWithWhereWithoutRouteInput {
  data: ScoreLeadUpdateManyMutationInput!
  where: ScoreLeadScalarWhereInput!
}

input ScoreLeadUpdateManyWithoutCommentInput {
  connect: [ScoreLeadWhereUniqueInput!]
  connectOrCreate: [ScoreLeadCreateOrConnectWithoutCommentInput!]
  create: [ScoreLeadCreateWithoutCommentInput!]
  createMany: ScoreLeadCreateManyCommentInputEnvelope
  delete: [ScoreLeadWhereUniqueInput!]
  deleteMany: [ScoreLeadScalarWhereInput!]
  disconnect: [ScoreLeadWhereUniqueInput!]
  set: [ScoreLeadWhereUniqueInput!]
  update: [ScoreLeadUpdateWithWhereUniqueWithoutCommentInput!]
  updateMany: [ScoreLeadUpdateManyWithWhereWithoutCommentInput!]
  upsert: [ScoreLeadUpsertWithWhereUniqueWithoutCommentInput!]
}

input ScoreLeadUpdateManyWithoutCompetitorInput {
  connect: [ScoreLeadWhereUniqueInput!]
  connectOrCreate: [ScoreLeadCreateOrConnectWithoutCompetitorInput!]
  create: [ScoreLeadCreateWithoutCompetitorInput!]
  createMany: ScoreLeadCreateManyCompetitorInputEnvelope
  delete: [ScoreLeadWhereUniqueInput!]
  deleteMany: [ScoreLeadScalarWhereInput!]
  disconnect: [ScoreLeadWhereUniqueInput!]
  set: [ScoreLeadWhereUniqueInput!]
  update: [ScoreLeadUpdateWithWhereUniqueWithoutCompetitorInput!]
  updateMany: [ScoreLeadUpdateManyWithWhereWithoutCompetitorInput!]
  upsert: [ScoreLeadUpsertWithWhereUniqueWithoutCompetitorInput!]
}

input ScoreLeadUpdateManyWithoutRouteInput {
  connect: [ScoreLeadWhereUniqueInput!]
  connectOrCreate: [ScoreLeadCreateOrConnectWithoutRouteInput!]
  create: [ScoreLeadCreateWithoutRouteInput!]
  createMany: ScoreLeadCreateManyRouteInputEnvelope
  delete: [ScoreLeadWhereUniqueInput!]
  deleteMany: [ScoreLeadScalarWhereInput!]
  disconnect: [ScoreLeadWhereUniqueInput!]
  set: [ScoreLeadWhereUniqueInput!]
  update: [ScoreLeadUpdateWithWhereUniqueWithoutRouteInput!]
  updateMany: [ScoreLeadUpdateManyWithWhereWithoutRouteInput!]
  upsert: [ScoreLeadUpsertWithWhereUniqueWithoutRouteInput!]
}

input ScoreLeadUpdateWithWhereUniqueWithoutCommentInput {
  data: ScoreLeadUpdateWithoutCommentInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadUpdateWithWhereUniqueWithoutCompetitorInput {
  data: ScoreLeadUpdateWithoutCompetitorInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadUpdateWithWhereUniqueWithoutRouteInput {
  data: ScoreLeadUpdateWithoutRouteInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadUpdateWithoutCommentInput {
  competitor: CompetitorUpdateOneRequiredWithoutScoresLeadInput
  createdAt: DateTimeFieldUpdateOperationsInput
  height: IntFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreLeadInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreLeadUpdateWithoutCompetitorInput {
  comment: CommentUpdateOneWithoutScoresLeadInput
  createdAt: DateTimeFieldUpdateOperationsInput
  height: IntFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreLeadInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreLeadUpdateWithoutRouteInput {
  comment: CommentUpdateOneWithoutScoresLeadInput
  competitor: CompetitorUpdateOneRequiredWithoutScoresLeadInput
  createdAt: DateTimeFieldUpdateOperationsInput
  height: IntFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreLeadUpsertWithWhereUniqueWithoutCommentInput {
  create: ScoreLeadCreateWithoutCommentInput!
  update: ScoreLeadUpdateWithoutCommentInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadUpsertWithWhereUniqueWithoutCompetitorInput {
  create: ScoreLeadCreateWithoutCompetitorInput!
  update: ScoreLeadUpdateWithoutCompetitorInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadUpsertWithWhereUniqueWithoutRouteInput {
  create: ScoreLeadCreateWithoutRouteInput!
  update: ScoreLeadUpdateWithoutRouteInput!
  where: ScoreLeadWhereUniqueInput!
}

input ScoreLeadWhereInput {
  AND: [ScoreLeadWhereInput!]
  NOT: [ScoreLeadWhereInput!]
  OR: [ScoreLeadWhereInput!]
  comment: CommentRelationFilter
  commentId: IntNullableFilter
  competitor: CompetitorRelationFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  height: IntFilter
  id: IntFilter
  route: RouteRelationFilter
  routeId: IntFilter
  time: IntFilter
  updatedAt: DateTimeFilter
}

input ScoreLeadWhereUniqueInput {
  id: Int
}

type ScoreSpeed {
  comment: Comment
  commentId: Int
  competitor: Competitor!
  competitorId: Int!
  createdAt: DateTime!
  id: Int!
  route: Route!
  routeId: Int!
  time: Int!
  updatedAt: DateTime!
}

type ScoreSpeedAvgAggregate {
  commentId: Float
  competitorId: Float!
  id: Float!
  routeId: Float!
  time: Float!
}

type ScoreSpeedCountAggregate {
  _all: Int!
  commentId: Int
  competitorId: Int!
  createdAt: Int
  id: Int!
  routeId: Int!
  time: Int!
  updatedAt: Int
}

input ScoreSpeedCreateInput {
  comment: CommentCreateNestedOneWithoutScoresSpeedInput
  competitor: CompetitorCreateNestedOneWithoutScoresSpeedInput!
  createdAt: DateTime
  route: RouteCreateNestedOneWithoutScoreSpeedInput!
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedCreateManyCommentInput {
  competitorId: Int!
  createdAt: DateTime
  id: Int
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedCreateManyCommentInputEnvelope {
  data: [ScoreSpeedCreateManyCommentInput!]!
  skipDuplicates: Boolean
}

input ScoreSpeedCreateManyCompetitorInput {
  commentId: Int
  createdAt: DateTime
  id: Int
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedCreateManyCompetitorInputEnvelope {
  data: [ScoreSpeedCreateManyCompetitorInput!]!
  skipDuplicates: Boolean
}

input ScoreSpeedCreateManyInput {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedCreateManyRouteInput {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedCreateManyRouteInputEnvelope {
  data: [ScoreSpeedCreateManyRouteInput!]!
  skipDuplicates: Boolean
}

input ScoreSpeedCreateNestedManyWithoutCommentInput {
  connect: [ScoreSpeedWhereUniqueInput!]
  connectOrCreate: [ScoreSpeedCreateOrConnectWithoutCommentInput!]
  create: [ScoreSpeedCreateWithoutCommentInput!]
  createMany: ScoreSpeedCreateManyCommentInputEnvelope
}

input ScoreSpeedCreateNestedManyWithoutCompetitorInput {
  connect: [ScoreSpeedWhereUniqueInput!]
  connectOrCreate: [ScoreSpeedCreateOrConnectWithoutCompetitorInput!]
  create: [ScoreSpeedCreateWithoutCompetitorInput!]
  createMany: ScoreSpeedCreateManyCompetitorInputEnvelope
}

input ScoreSpeedCreateNestedManyWithoutRouteInput {
  connect: [ScoreSpeedWhereUniqueInput!]
  connectOrCreate: [ScoreSpeedCreateOrConnectWithoutRouteInput!]
  create: [ScoreSpeedCreateWithoutRouteInput!]
  createMany: ScoreSpeedCreateManyRouteInputEnvelope
}

input ScoreSpeedCreateOrConnectWithoutCommentInput {
  create: ScoreSpeedCreateWithoutCommentInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedCreateOrConnectWithoutCompetitorInput {
  create: ScoreSpeedCreateWithoutCompetitorInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedCreateOrConnectWithoutRouteInput {
  create: ScoreSpeedCreateWithoutRouteInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedCreateWithoutCommentInput {
  competitor: CompetitorCreateNestedOneWithoutScoresSpeedInput!
  createdAt: DateTime
  route: RouteCreateNestedOneWithoutScoreSpeedInput!
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedCreateWithoutCompetitorInput {
  comment: CommentCreateNestedOneWithoutScoresSpeedInput
  createdAt: DateTime
  route: RouteCreateNestedOneWithoutScoreSpeedInput!
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedCreateWithoutRouteInput {
  comment: CommentCreateNestedOneWithoutScoresSpeedInput
  competitor: CompetitorCreateNestedOneWithoutScoresSpeedInput!
  createdAt: DateTime
  time: Int!
  updatedAt: DateTime
}

type ScoreSpeedGroupBy {
  avg: ScoreSpeedAvgAggregate
  commentId: Int
  competitorId: Int!
  count: ScoreSpeedCountAggregate
  createdAt: DateTime!
  id: Int!
  max: ScoreSpeedMaxAggregate
  min: ScoreSpeedMinAggregate
  routeId: Int!
  sum: ScoreSpeedSumAggregate
  time: Int!
  updatedAt: DateTime!
}

input ScoreSpeedListRelationFilter {
  every: ScoreSpeedWhereInput
  none: ScoreSpeedWhereInput
  some: ScoreSpeedWhereInput
}

type ScoreSpeedMaxAggregate {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

type ScoreSpeedMinAggregate {
  commentId: Int
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  routeId: Int!
  time: Int!
  updatedAt: DateTime
}

input ScoreSpeedOrderByInput {
  commentId: SortOrder
  competitorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  routeId: SortOrder
  time: SortOrder
  updatedAt: SortOrder
}

enum ScoreSpeedScalarFieldEnum {
  commentId
  competitorId
  createdAt
  id
  routeId
  time
  updatedAt
}

input ScoreSpeedScalarWhereInput {
  AND: [ScoreSpeedScalarWhereInput!]
  NOT: [ScoreSpeedScalarWhereInput!]
  OR: [ScoreSpeedScalarWhereInput!]
  commentId: IntNullableFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  routeId: IntFilter
  time: IntFilter
  updatedAt: DateTimeFilter
}

input ScoreSpeedScalarWhereWithAggregatesInput {
  AND: [ScoreSpeedScalarWhereWithAggregatesInput!]
  NOT: [ScoreSpeedScalarWhereWithAggregatesInput!]
  OR: [ScoreSpeedScalarWhereWithAggregatesInput!]
  commentId: IntNullableWithAggregatesFilter
  competitorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  routeId: IntWithAggregatesFilter
  time: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ScoreSpeedSumAggregate {
  commentId: Int
  competitorId: Int!
  id: Int!
  routeId: Int!
  time: Int!
}

input ScoreSpeedUpdateInput {
  comment: CommentUpdateOneWithoutScoresSpeedInput
  competitor: CompetitorUpdateOneRequiredWithoutScoresSpeedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreSpeedInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreSpeedUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreSpeedUpdateManyWithWhereWithoutCommentInput {
  data: ScoreSpeedUpdateManyMutationInput!
  where: ScoreSpeedScalarWhereInput!
}

input ScoreSpeedUpdateManyWithWhereWithoutCompetitorInput {
  data: ScoreSpeedUpdateManyMutationInput!
  where: ScoreSpeedScalarWhereInput!
}

input ScoreSpeedUpdateManyWithWhereWithoutRouteInput {
  data: ScoreSpeedUpdateManyMutationInput!
  where: ScoreSpeedScalarWhereInput!
}

input ScoreSpeedUpdateManyWithoutCommentInput {
  connect: [ScoreSpeedWhereUniqueInput!]
  connectOrCreate: [ScoreSpeedCreateOrConnectWithoutCommentInput!]
  create: [ScoreSpeedCreateWithoutCommentInput!]
  createMany: ScoreSpeedCreateManyCommentInputEnvelope
  delete: [ScoreSpeedWhereUniqueInput!]
  deleteMany: [ScoreSpeedScalarWhereInput!]
  disconnect: [ScoreSpeedWhereUniqueInput!]
  set: [ScoreSpeedWhereUniqueInput!]
  update: [ScoreSpeedUpdateWithWhereUniqueWithoutCommentInput!]
  updateMany: [ScoreSpeedUpdateManyWithWhereWithoutCommentInput!]
  upsert: [ScoreSpeedUpsertWithWhereUniqueWithoutCommentInput!]
}

input ScoreSpeedUpdateManyWithoutCompetitorInput {
  connect: [ScoreSpeedWhereUniqueInput!]
  connectOrCreate: [ScoreSpeedCreateOrConnectWithoutCompetitorInput!]
  create: [ScoreSpeedCreateWithoutCompetitorInput!]
  createMany: ScoreSpeedCreateManyCompetitorInputEnvelope
  delete: [ScoreSpeedWhereUniqueInput!]
  deleteMany: [ScoreSpeedScalarWhereInput!]
  disconnect: [ScoreSpeedWhereUniqueInput!]
  set: [ScoreSpeedWhereUniqueInput!]
  update: [ScoreSpeedUpdateWithWhereUniqueWithoutCompetitorInput!]
  updateMany: [ScoreSpeedUpdateManyWithWhereWithoutCompetitorInput!]
  upsert: [ScoreSpeedUpsertWithWhereUniqueWithoutCompetitorInput!]
}

input ScoreSpeedUpdateManyWithoutRouteInput {
  connect: [ScoreSpeedWhereUniqueInput!]
  connectOrCreate: [ScoreSpeedCreateOrConnectWithoutRouteInput!]
  create: [ScoreSpeedCreateWithoutRouteInput!]
  createMany: ScoreSpeedCreateManyRouteInputEnvelope
  delete: [ScoreSpeedWhereUniqueInput!]
  deleteMany: [ScoreSpeedScalarWhereInput!]
  disconnect: [ScoreSpeedWhereUniqueInput!]
  set: [ScoreSpeedWhereUniqueInput!]
  update: [ScoreSpeedUpdateWithWhereUniqueWithoutRouteInput!]
  updateMany: [ScoreSpeedUpdateManyWithWhereWithoutRouteInput!]
  upsert: [ScoreSpeedUpsertWithWhereUniqueWithoutRouteInput!]
}

input ScoreSpeedUpdateWithWhereUniqueWithoutCommentInput {
  data: ScoreSpeedUpdateWithoutCommentInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedUpdateWithWhereUniqueWithoutCompetitorInput {
  data: ScoreSpeedUpdateWithoutCompetitorInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedUpdateWithWhereUniqueWithoutRouteInput {
  data: ScoreSpeedUpdateWithoutRouteInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedUpdateWithoutCommentInput {
  competitor: CompetitorUpdateOneRequiredWithoutScoresSpeedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreSpeedInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreSpeedUpdateWithoutCompetitorInput {
  comment: CommentUpdateOneWithoutScoresSpeedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  route: RouteUpdateOneRequiredWithoutScoreSpeedInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreSpeedUpdateWithoutRouteInput {
  comment: CommentUpdateOneWithoutScoresSpeedInput
  competitor: CompetitorUpdateOneRequiredWithoutScoresSpeedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ScoreSpeedUpsertWithWhereUniqueWithoutCommentInput {
  create: ScoreSpeedCreateWithoutCommentInput!
  update: ScoreSpeedUpdateWithoutCommentInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedUpsertWithWhereUniqueWithoutCompetitorInput {
  create: ScoreSpeedCreateWithoutCompetitorInput!
  update: ScoreSpeedUpdateWithoutCompetitorInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedUpsertWithWhereUniqueWithoutRouteInput {
  create: ScoreSpeedCreateWithoutRouteInput!
  update: ScoreSpeedUpdateWithoutRouteInput!
  where: ScoreSpeedWhereUniqueInput!
}

input ScoreSpeedWhereInput {
  AND: [ScoreSpeedWhereInput!]
  NOT: [ScoreSpeedWhereInput!]
  OR: [ScoreSpeedWhereInput!]
  comment: CommentRelationFilter
  commentId: IntNullableFilter
  competitor: CompetitorRelationFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  route: RouteRelationFilter
  routeId: IntFilter
  time: IntFilter
  updatedAt: DateTimeFilter
}

input ScoreSpeedWhereUniqueInput {
  id: Int
}

type Season {
  competitions(cursor: CompetitionWhereUniqueInput, distinct: [CompetitionScalarFieldEnum!], orderBy: [CompetitionOrderByInput!], skip: Int, take: Int, where: CompetitionWhereInput): [Competition!]!
  createdAt: DateTime!
  description: String
  endDate: DateTime!
  id: Int!
  name: String!
  stardDate: DateTime!
  updatedAt: DateTime!
  year: Int
}

type SeasonAvgAggregate {
  id: Float!
  year: Float
}

type SeasonCountAggregate {
  _all: Int!
  createdAt: Int
  description: Int
  endDate: Int
  id: Int!
  name: Int
  stardDate: Int
  updatedAt: Int
  year: Int
}

input SeasonCreateInput {
  competitions: CompetitionCreateNestedManyWithoutSeasonInput
  createdAt: DateTime
  description: String
  endDate: DateTime!
  name: String!
  stardDate: DateTime!
  updatedAt: DateTime
  year: Int
}

input SeasonCreateManyInput {
  createdAt: DateTime
  description: String
  endDate: DateTime!
  id: Int
  name: String!
  stardDate: DateTime!
  updatedAt: DateTime
  year: Int
}

input SeasonCreateNestedOneWithoutCompetitionsInput {
  connect: SeasonWhereUniqueInput
  connectOrCreate: SeasonCreateOrConnectWithoutCompetitionsInput
  create: SeasonCreateWithoutCompetitionsInput
}

input SeasonCreateOrConnectWithoutCompetitionsInput {
  create: SeasonCreateWithoutCompetitionsInput!
  where: SeasonWhereUniqueInput!
}

input SeasonCreateWithoutCompetitionsInput {
  createdAt: DateTime
  description: String
  endDate: DateTime!
  name: String!
  stardDate: DateTime!
  updatedAt: DateTime
  year: Int
}

type SeasonGroupBy {
  avg: SeasonAvgAggregate
  count: SeasonCountAggregate
  createdAt: DateTime!
  description: String
  endDate: DateTime!
  id: Int!
  max: SeasonMaxAggregate
  min: SeasonMinAggregate
  name: String!
  stardDate: DateTime!
  sum: SeasonSumAggregate
  updatedAt: DateTime!
  year: Int
}

type SeasonMaxAggregate {
  createdAt: DateTime
  description: String
  endDate: DateTime
  id: Int!
  name: String
  stardDate: DateTime
  updatedAt: DateTime
  year: Int
}

type SeasonMinAggregate {
  createdAt: DateTime
  description: String
  endDate: DateTime
  id: Int!
  name: String
  stardDate: DateTime
  updatedAt: DateTime
  year: Int
}

input SeasonOrderByInput {
  createdAt: SortOrder
  description: SortOrder
  endDate: SortOrder
  id: SortOrder
  name: SortOrder
  stardDate: SortOrder
  updatedAt: SortOrder
  year: SortOrder
}

input SeasonRelationFilter {
  is: SeasonWhereInput
  isNot: SeasonWhereInput
}

enum SeasonScalarFieldEnum {
  createdAt
  description
  endDate
  id
  name
  stardDate
  updatedAt
  year
}

input SeasonScalarWhereWithAggregatesInput {
  AND: [SeasonScalarWhereWithAggregatesInput!]
  NOT: [SeasonScalarWhereWithAggregatesInput!]
  OR: [SeasonScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  endDate: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  stardDate: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  year: IntNullableWithAggregatesFilter
}

type SeasonSumAggregate {
  id: Int!
  year: Int
}

input SeasonUpdateInput {
  competitions: CompetitionUpdateManyWithoutSeasonInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stardDate: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: NullableIntFieldUpdateOperationsInput
}

input SeasonUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stardDate: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: NullableIntFieldUpdateOperationsInput
}

input SeasonUpdateOneRequiredWithoutCompetitionsInput {
  connect: SeasonWhereUniqueInput
  connectOrCreate: SeasonCreateOrConnectWithoutCompetitionsInput
  create: SeasonCreateWithoutCompetitionsInput
  update: SeasonUpdateWithoutCompetitionsInput
  upsert: SeasonUpsertWithoutCompetitionsInput
}

input SeasonUpdateWithoutCompetitionsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  endDate: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  stardDate: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  year: NullableIntFieldUpdateOperationsInput
}

input SeasonUpsertWithoutCompetitionsInput {
  create: SeasonCreateWithoutCompetitionsInput!
  update: SeasonUpdateWithoutCompetitionsInput!
}

input SeasonWhereInput {
  AND: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  competitions: CompetitionListRelationFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  endDate: DateTimeFilter
  id: IntFilter
  name: StringFilter
  stardDate: DateTimeFilter
  updatedAt: DateTimeFilter
  year: IntNullableFilter
}

input SeasonWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

type StartList {
  competition: Competition!
  competitionId: Int!
  competitor: Competitor!
  competitorId: Int!
  createdAt: DateTime!
  id: Int!
  startNumber: Int!
  updatedAt: DateTime!
}

type StartListAvgAggregate {
  competitionId: Float!
  competitorId: Float!
  id: Float!
  startNumber: Float!
}

type StartListCountAggregate {
  _all: Int!
  competitionId: Int!
  competitorId: Int!
  createdAt: Int
  id: Int!
  startNumber: Int!
  updatedAt: Int
}

input StartListCreateInput {
  competition: CompetitionCreateNestedOneWithoutStartListsInput!
  competitor: CompetitorCreateNestedOneWithoutStartListsInput!
  createdAt: DateTime
  startNumber: Int!
  updatedAt: DateTime
}

input StartListCreateManyCompetitionInput {
  competitorId: Int!
  createdAt: DateTime
  id: Int
  startNumber: Int!
  updatedAt: DateTime
}

input StartListCreateManyCompetitionInputEnvelope {
  data: [StartListCreateManyCompetitionInput!]!
  skipDuplicates: Boolean
}

input StartListCreateManyCompetitorInput {
  competitionId: Int!
  createdAt: DateTime
  id: Int
  startNumber: Int!
  updatedAt: DateTime
}

input StartListCreateManyCompetitorInputEnvelope {
  data: [StartListCreateManyCompetitorInput!]!
  skipDuplicates: Boolean
}

input StartListCreateManyInput {
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int
  startNumber: Int!
  updatedAt: DateTime
}

input StartListCreateNestedManyWithoutCompetitionInput {
  connect: [StartListWhereUniqueInput!]
  connectOrCreate: [StartListCreateOrConnectWithoutCompetitionInput!]
  create: [StartListCreateWithoutCompetitionInput!]
  createMany: StartListCreateManyCompetitionInputEnvelope
}

input StartListCreateNestedManyWithoutCompetitorInput {
  connect: [StartListWhereUniqueInput!]
  connectOrCreate: [StartListCreateOrConnectWithoutCompetitorInput!]
  create: [StartListCreateWithoutCompetitorInput!]
  createMany: StartListCreateManyCompetitorInputEnvelope
}

input StartListCreateOrConnectWithoutCompetitionInput {
  create: StartListCreateWithoutCompetitionInput!
  where: StartListWhereUniqueInput!
}

input StartListCreateOrConnectWithoutCompetitorInput {
  create: StartListCreateWithoutCompetitorInput!
  where: StartListWhereUniqueInput!
}

input StartListCreateWithoutCompetitionInput {
  competitor: CompetitorCreateNestedOneWithoutStartListsInput!
  createdAt: DateTime
  startNumber: Int!
  updatedAt: DateTime
}

input StartListCreateWithoutCompetitorInput {
  competition: CompetitionCreateNestedOneWithoutStartListsInput!
  createdAt: DateTime
  startNumber: Int!
  updatedAt: DateTime
}

type StartListGroupBy {
  avg: StartListAvgAggregate
  competitionId: Int!
  competitorId: Int!
  count: StartListCountAggregate
  createdAt: DateTime!
  id: Int!
  max: StartListMaxAggregate
  min: StartListMinAggregate
  startNumber: Int!
  sum: StartListSumAggregate
  updatedAt: DateTime!
}

input StartListListRelationFilter {
  every: StartListWhereInput
  none: StartListWhereInput
  some: StartListWhereInput
}

type StartListMaxAggregate {
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  startNumber: Int!
  updatedAt: DateTime
}

type StartListMinAggregate {
  competitionId: Int!
  competitorId: Int!
  createdAt: DateTime
  id: Int!
  startNumber: Int!
  updatedAt: DateTime
}

input StartListOrderByInput {
  competitionId: SortOrder
  competitorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  startNumber: SortOrder
  updatedAt: SortOrder
}

enum StartListScalarFieldEnum {
  competitionId
  competitorId
  createdAt
  id
  startNumber
  updatedAt
}

input StartListScalarWhereInput {
  AND: [StartListScalarWhereInput!]
  NOT: [StartListScalarWhereInput!]
  OR: [StartListScalarWhereInput!]
  competitionId: IntFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  startNumber: IntFilter
  updatedAt: DateTimeFilter
}

input StartListScalarWhereWithAggregatesInput {
  AND: [StartListScalarWhereWithAggregatesInput!]
  NOT: [StartListScalarWhereWithAggregatesInput!]
  OR: [StartListScalarWhereWithAggregatesInput!]
  competitionId: IntWithAggregatesFilter
  competitorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  startNumber: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type StartListSumAggregate {
  competitionId: Int!
  competitorId: Int!
  id: Int!
  startNumber: Int!
}

input StartListUpdateInput {
  competition: CompetitionUpdateOneRequiredWithoutStartListsInput
  competitor: CompetitorUpdateOneRequiredWithoutStartListsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  startNumber: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StartListUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  startNumber: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StartListUpdateManyWithWhereWithoutCompetitionInput {
  data: StartListUpdateManyMutationInput!
  where: StartListScalarWhereInput!
}

input StartListUpdateManyWithWhereWithoutCompetitorInput {
  data: StartListUpdateManyMutationInput!
  where: StartListScalarWhereInput!
}

input StartListUpdateManyWithoutCompetitionInput {
  connect: [StartListWhereUniqueInput!]
  connectOrCreate: [StartListCreateOrConnectWithoutCompetitionInput!]
  create: [StartListCreateWithoutCompetitionInput!]
  createMany: StartListCreateManyCompetitionInputEnvelope
  delete: [StartListWhereUniqueInput!]
  deleteMany: [StartListScalarWhereInput!]
  disconnect: [StartListWhereUniqueInput!]
  set: [StartListWhereUniqueInput!]
  update: [StartListUpdateWithWhereUniqueWithoutCompetitionInput!]
  updateMany: [StartListUpdateManyWithWhereWithoutCompetitionInput!]
  upsert: [StartListUpsertWithWhereUniqueWithoutCompetitionInput!]
}

input StartListUpdateManyWithoutCompetitorInput {
  connect: [StartListWhereUniqueInput!]
  connectOrCreate: [StartListCreateOrConnectWithoutCompetitorInput!]
  create: [StartListCreateWithoutCompetitorInput!]
  createMany: StartListCreateManyCompetitorInputEnvelope
  delete: [StartListWhereUniqueInput!]
  deleteMany: [StartListScalarWhereInput!]
  disconnect: [StartListWhereUniqueInput!]
  set: [StartListWhereUniqueInput!]
  update: [StartListUpdateWithWhereUniqueWithoutCompetitorInput!]
  updateMany: [StartListUpdateManyWithWhereWithoutCompetitorInput!]
  upsert: [StartListUpsertWithWhereUniqueWithoutCompetitorInput!]
}

input StartListUpdateWithWhereUniqueWithoutCompetitionInput {
  data: StartListUpdateWithoutCompetitionInput!
  where: StartListWhereUniqueInput!
}

input StartListUpdateWithWhereUniqueWithoutCompetitorInput {
  data: StartListUpdateWithoutCompetitorInput!
  where: StartListWhereUniqueInput!
}

input StartListUpdateWithoutCompetitionInput {
  competitor: CompetitorUpdateOneRequiredWithoutStartListsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  startNumber: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StartListUpdateWithoutCompetitorInput {
  competition: CompetitionUpdateOneRequiredWithoutStartListsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  startNumber: IntFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input StartListUpsertWithWhereUniqueWithoutCompetitionInput {
  create: StartListCreateWithoutCompetitionInput!
  update: StartListUpdateWithoutCompetitionInput!
  where: StartListWhereUniqueInput!
}

input StartListUpsertWithWhereUniqueWithoutCompetitorInput {
  create: StartListCreateWithoutCompetitorInput!
  update: StartListUpdateWithoutCompetitorInput!
  where: StartListWhereUniqueInput!
}

input StartListWhereInput {
  AND: [StartListWhereInput!]
  NOT: [StartListWhereInput!]
  OR: [StartListWhereInput!]
  competition: CompetitionRelationFilter
  competitionId: IntFilter
  competitor: CompetitorRelationFilter
  competitorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  startNumber: IntFilter
  updatedAt: DateTimeFilter
}

input StartListWhereUniqueInput {
  id: Int
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  contains: String
  count: NestedIntNullableFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  max: NestedStringNullableFilter
  min: NestedStringNullableFilter
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  contains: String
  count: NestedIntFilter
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  max: NestedStringFilter
  min: NestedStringFilter
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  acceptances(cursor: RegistrationWhereUniqueInput, distinct: [RegistrationScalarFieldEnum!], orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): [Registration!]!
  comments(cursor: CommentWhereUniqueInput, distinct: [CommentScalarFieldEnum!], orderBy: [CommentOrderByInput!], skip: Int, take: Int, where: CommentWhereInput): [Comment!]!
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: Int!
  lastName: String!
  location: Location
  locationId: Int
  password: String!
  publicId: String!
  registrations(cursor: RegistrationWhereUniqueInput, distinct: [RegistrationScalarFieldEnum!], orderBy: [RegistrationOrderByInput!], skip: Int, take: Int, where: RegistrationWhereInput): [Registration!]!
  results(cursor: ResultWhereUniqueInput, distinct: [ResultScalarFieldEnum!], orderBy: [ResultOrderByInput!], skip: Int, take: Int, where: ResultWhereInput): [Result!]!
  role: UserRole!
  routesJudged(cursor: RouteWhereUniqueInput, distinct: [RouteScalarFieldEnum!], orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): [Route!]!
  routesSet(cursor: RouteWhereUniqueInput, distinct: [RouteScalarFieldEnum!], orderBy: [RouteOrderByInput!], skip: Int, take: Int, where: RouteWhereInput): [Route!]!
  updatedAt: DateTime!
}

type UserAvgAggregate {
  id: Float!
  locationId: Float
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int
  email: Int
  firstName: Int
  id: Int!
  lastName: Int
  locationId: Int
  password: Int
  publicId: Int
  role: Int
  updatedAt: Int
}

input UserCreateInput {
  acceptances: RegistrationCreateNestedManyWithoutAcceptorInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUsersInput
  password: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutRegistrantInput
  results: ResultCreateNestedManyWithoutApprovedByInput
  role: UserRole
  routesJudged: RouteCreateNestedManyWithoutJudgeInput
  routesSet: RouteCreateNestedManyWithoutSetterInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  firstName: String!
  id: Int
  lastName: String!
  locationId: Int
  password: String!
  publicId: String
  role: UserRole
  updatedAt: DateTime
}

input UserCreateManyLocationInput {
  createdAt: DateTime
  email: String!
  firstName: String!
  id: Int
  lastName: String!
  password: String!
  publicId: String
  role: UserRole
  updatedAt: DateTime
}

input UserCreateManyLocationInputEnvelope {
  data: [UserCreateManyLocationInput!]!
  skipDuplicates: Boolean
}

input UserCreateNestedManyWithoutLocationInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutLocationInput!]
  create: [UserCreateWithoutLocationInput!]
  createMany: UserCreateManyLocationInputEnvelope
}

input UserCreateNestedOneWithoutAcceptancesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAcceptancesInput
  create: UserCreateWithoutAcceptancesInput
}

input UserCreateNestedOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
}

input UserCreateNestedOneWithoutRegistrationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRegistrationsInput
  create: UserCreateWithoutRegistrationsInput
}

input UserCreateNestedOneWithoutResultsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutResultsInput
  create: UserCreateWithoutResultsInput
}

input UserCreateNestedOneWithoutRoutesJudgedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRoutesJudgedInput
  create: UserCreateWithoutRoutesJudgedInput
}

input UserCreateNestedOneWithoutRoutesSetInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRoutesSetInput
  create: UserCreateWithoutRoutesSetInput
}

input UserCreateOrConnectWithoutAcceptancesInput {
  create: UserCreateWithoutAcceptancesInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutLocationInput {
  create: UserCreateWithoutLocationInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRegistrationsInput {
  create: UserCreateWithoutRegistrationsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutResultsInput {
  create: UserCreateWithoutResultsInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRoutesJudgedInput {
  create: UserCreateWithoutRoutesJudgedInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutRoutesSetInput {
  create: UserCreateWithoutRoutesSetInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAcceptancesInput {
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUsersInput
  password: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutRegistrantInput
  results: ResultCreateNestedManyWithoutApprovedByInput
  role: UserRole
  routesJudged: RouteCreateNestedManyWithoutJudgeInput
  routesSet: RouteCreateNestedManyWithoutSetterInput
  updatedAt: DateTime
}

input UserCreateWithoutCommentsInput {
  acceptances: RegistrationCreateNestedManyWithoutAcceptorInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUsersInput
  password: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutRegistrantInput
  results: ResultCreateNestedManyWithoutApprovedByInput
  role: UserRole
  routesJudged: RouteCreateNestedManyWithoutJudgeInput
  routesSet: RouteCreateNestedManyWithoutSetterInput
  updatedAt: DateTime
}

input UserCreateWithoutLocationInput {
  acceptances: RegistrationCreateNestedManyWithoutAcceptorInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  password: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutRegistrantInput
  results: ResultCreateNestedManyWithoutApprovedByInput
  role: UserRole
  routesJudged: RouteCreateNestedManyWithoutJudgeInput
  routesSet: RouteCreateNestedManyWithoutSetterInput
  updatedAt: DateTime
}

input UserCreateWithoutRegistrationsInput {
  acceptances: RegistrationCreateNestedManyWithoutAcceptorInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUsersInput
  password: String!
  publicId: String
  results: ResultCreateNestedManyWithoutApprovedByInput
  role: UserRole
  routesJudged: RouteCreateNestedManyWithoutJudgeInput
  routesSet: RouteCreateNestedManyWithoutSetterInput
  updatedAt: DateTime
}

input UserCreateWithoutResultsInput {
  acceptances: RegistrationCreateNestedManyWithoutAcceptorInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUsersInput
  password: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutRegistrantInput
  role: UserRole
  routesJudged: RouteCreateNestedManyWithoutJudgeInput
  routesSet: RouteCreateNestedManyWithoutSetterInput
  updatedAt: DateTime
}

input UserCreateWithoutRoutesJudgedInput {
  acceptances: RegistrationCreateNestedManyWithoutAcceptorInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUsersInput
  password: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutRegistrantInput
  results: ResultCreateNestedManyWithoutApprovedByInput
  role: UserRole
  routesSet: RouteCreateNestedManyWithoutSetterInput
  updatedAt: DateTime
}

input UserCreateWithoutRoutesSetInput {
  acceptances: RegistrationCreateNestedManyWithoutAcceptorInput
  comments: CommentCreateNestedManyWithoutUserInput
  createdAt: DateTime
  email: String!
  firstName: String!
  lastName: String!
  location: LocationCreateNestedOneWithoutUsersInput
  password: String!
  publicId: String
  registrations: RegistrationCreateNestedManyWithoutRegistrantInput
  results: ResultCreateNestedManyWithoutApprovedByInput
  role: UserRole
  routesJudged: RouteCreateNestedManyWithoutJudgeInput
  updatedAt: DateTime
}

type UserGroupBy {
  avg: UserAvgAggregate
  count: UserCountAggregate
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: Int!
  lastName: String!
  locationId: Int
  max: UserMaxAggregate
  min: UserMinAggregate
  password: String!
  publicId: String!
  role: UserRole!
  sum: UserSumAggregate
  updatedAt: DateTime!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: Int!
  lastName: String
  locationId: Int
  password: String
  publicId: String
  role: UserRole
  updatedAt: DateTime
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  firstName: String
  id: Int!
  lastName: String
  locationId: Int
  password: String
  publicId: String
  role: UserRole
  updatedAt: DateTime
}

input UserOrderByInput {
  createdAt: SortOrder
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  locationId: SortOrder
  password: SortOrder
  publicId: SortOrder
  role: SortOrder
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserRole {
  ADMINISTRATOR
  JUDGE
  MODERATOR
  USER
}

enum UserScalarFieldEnum {
  createdAt
  email
  firstName
  id
  lastName
  locationId
  password
  publicId
  role
  updatedAt
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: IntFilter
  lastName: StringFilter
  locationId: IntNullableFilter
  password: StringFilter
  publicId: StringFilter
  role: EnumUserRoleFilter
  updatedAt: DateTimeFilter
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  locationId: IntNullableWithAggregatesFilter
  password: StringWithAggregatesFilter
  publicId: StringWithAggregatesFilter
  role: EnumUserRoleWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int!
  locationId: Int
}

input UserUpdateInput {
  acceptances: RegistrationUpdateManyWithoutAcceptorInput
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUsersInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutRegistrantInput
  results: ResultUpdateManyWithoutApprovedByInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesJudged: RouteUpdateManyWithoutJudgeInput
  routesSet: RouteUpdateManyWithoutSetterInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  role: EnumUserRoleFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyWithWhereWithoutLocationInput {
  data: UserUpdateManyMutationInput!
  where: UserScalarWhereInput!
}

input UserUpdateManyWithoutLocationInput {
  connect: [UserWhereUniqueInput!]
  connectOrCreate: [UserCreateOrConnectWithoutLocationInput!]
  create: [UserCreateWithoutLocationInput!]
  createMany: UserCreateManyLocationInputEnvelope
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLocationInput!]
  updateMany: [UserUpdateManyWithWhereWithoutLocationInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLocationInput!]
}

input UserUpdateOneRequiredWithoutAcceptancesInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAcceptancesInput
  create: UserCreateWithoutAcceptancesInput
  update: UserUpdateWithoutAcceptancesInput
  upsert: UserUpsertWithoutAcceptancesInput
}

input UserUpdateOneRequiredWithoutRegistrationsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRegistrationsInput
  create: UserCreateWithoutRegistrationsInput
  update: UserUpdateWithoutRegistrationsInput
  upsert: UserUpsertWithoutRegistrationsInput
}

input UserUpdateOneRequiredWithoutResultsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutResultsInput
  create: UserCreateWithoutResultsInput
  update: UserUpdateWithoutResultsInput
  upsert: UserUpsertWithoutResultsInput
}

input UserUpdateOneRequiredWithoutRoutesJudgedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRoutesJudgedInput
  create: UserCreateWithoutRoutesJudgedInput
  update: UserUpdateWithoutRoutesJudgedInput
  upsert: UserUpsertWithoutRoutesJudgedInput
}

input UserUpdateOneRequiredWithoutRoutesSetInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutRoutesSetInput
  create: UserCreateWithoutRoutesSetInput
  update: UserUpdateWithoutRoutesSetInput
  upsert: UserUpsertWithoutRoutesSetInput
}

input UserUpdateOneWithoutCommentsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutCommentsInput
  create: UserCreateWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutCommentsInput
  upsert: UserUpsertWithoutCommentsInput
}

input UserUpdateWithWhereUniqueWithoutLocationInput {
  data: UserUpdateWithoutLocationInput!
  where: UserWhereUniqueInput!
}

input UserUpdateWithoutAcceptancesInput {
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUsersInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutRegistrantInput
  results: ResultUpdateManyWithoutApprovedByInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesJudged: RouteUpdateManyWithoutJudgeInput
  routesSet: RouteUpdateManyWithoutSetterInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutCommentsInput {
  acceptances: RegistrationUpdateManyWithoutAcceptorInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUsersInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutRegistrantInput
  results: ResultUpdateManyWithoutApprovedByInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesJudged: RouteUpdateManyWithoutJudgeInput
  routesSet: RouteUpdateManyWithoutSetterInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutLocationInput {
  acceptances: RegistrationUpdateManyWithoutAcceptorInput
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutRegistrantInput
  results: ResultUpdateManyWithoutApprovedByInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesJudged: RouteUpdateManyWithoutJudgeInput
  routesSet: RouteUpdateManyWithoutSetterInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutRegistrationsInput {
  acceptances: RegistrationUpdateManyWithoutAcceptorInput
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUsersInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  results: ResultUpdateManyWithoutApprovedByInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesJudged: RouteUpdateManyWithoutJudgeInput
  routesSet: RouteUpdateManyWithoutSetterInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutResultsInput {
  acceptances: RegistrationUpdateManyWithoutAcceptorInput
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUsersInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutRegistrantInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesJudged: RouteUpdateManyWithoutJudgeInput
  routesSet: RouteUpdateManyWithoutSetterInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutRoutesJudgedInput {
  acceptances: RegistrationUpdateManyWithoutAcceptorInput
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUsersInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutRegistrantInput
  results: ResultUpdateManyWithoutApprovedByInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesSet: RouteUpdateManyWithoutSetterInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateWithoutRoutesSetInput {
  acceptances: RegistrationUpdateManyWithoutAcceptorInput
  comments: CommentUpdateManyWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  location: LocationUpdateOneWithoutUsersInput
  password: StringFieldUpdateOperationsInput
  publicId: StringFieldUpdateOperationsInput
  registrations: RegistrationUpdateManyWithoutRegistrantInput
  results: ResultUpdateManyWithoutApprovedByInput
  role: EnumUserRoleFieldUpdateOperationsInput
  routesJudged: RouteUpdateManyWithoutJudgeInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithWhereUniqueWithoutLocationInput {
  create: UserCreateWithoutLocationInput!
  update: UserUpdateWithoutLocationInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutAcceptancesInput {
  create: UserCreateWithoutAcceptancesInput!
  update: UserUpdateWithoutAcceptancesInput!
}

input UserUpsertWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput!
  update: UserUpdateWithoutCommentsInput!
}

input UserUpsertWithoutRegistrationsInput {
  create: UserCreateWithoutRegistrationsInput!
  update: UserUpdateWithoutRegistrationsInput!
}

input UserUpsertWithoutResultsInput {
  create: UserCreateWithoutResultsInput!
  update: UserUpdateWithoutResultsInput!
}

input UserUpsertWithoutRoutesJudgedInput {
  create: UserCreateWithoutRoutesJudgedInput!
  update: UserUpdateWithoutRoutesJudgedInput!
}

input UserUpsertWithoutRoutesSetInput {
  create: UserCreateWithoutRoutesSetInput!
  update: UserUpdateWithoutRoutesSetInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  acceptances: RegistrationListRelationFilter
  comments: CommentListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: IntFilter
  lastName: StringFilter
  location: LocationRelationFilter
  locationId: IntNullableFilter
  password: StringFilter
  publicId: StringFilter
  registrations: RegistrationListRelationFilter
  results: ResultListRelationFilter
  role: EnumUserRoleFilter
  routesJudged: RouteListRelationFilter
  routesSet: RouteListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
  publicId: String
}
